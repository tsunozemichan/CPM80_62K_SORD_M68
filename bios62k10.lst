                                ;*** AILZ80ASM *** Z-80 Assembler, version 1.0.27.0, LST:Full:4
                                ;   skeletal cbios for first level of CP/M 2.0 alteration
                                ;
       003E                     msize   EQU 62  ;cp/m version memory size in kilobytes
                                ;
                                ;   "bias" is address offset from 3400h for memory systems
                                ;   than 16k (referred to as"b" throughout the text)
                                ;
       A800                     bias    EQU (MSIZE-20)*1024
       DC00                     ccp     EQU 3400H+BIAS  ;base of ccp
       E406                     bdos    EQU CCP+806H    ;base of bdos
       F200                     bios    EQU CCP+1600H   ;base of bios
       0004                     cdisk   EQU 0004H   ;current disk number 0=a,... l5=p
       0003                     iobyte  EQU 0003H   ;intel i/o byte
                                ;
                                
                                ;
                                ; SIO I/O ports
                                ;
       00F8                     SIOAD EQU 0F8H
       00F9                     SIOAC EQU 0F9H
                                
                                ;
                                ; FDC I/O ports
                                ;
       00C8                     FDC_COMMAND_REG EQU 0C8H
       00C8                     FDC_STATUS_REG  EQU FDC_COMMAND_REG
       00C9                     FDC_TRACK_REG   EQU 0C9H
       00CA                     FDC_SECTOR_REG  EQU 0CAH
       00CB                     FDC_DATA_REG    EQU 0CBH
       00CC                     DMA_ADDRESS     EQU 0CCH
       00CD                     FDC_CONTROL_REG EQU 0CDH
       00CE                     DMA_BANK_SEL    EQU 0CEH
                                
                                
                                ;
                                ; CRTC ports
                                ;
       F800                     VRAM_TXT_TOP EQU 0F800H
       F000                     VRAM_ATR_TOP EQU 0F000H
       00F0                     CRTC_ADD EQU 0F0H
       00F1                     CRTC_VAL EQU 0F1H
       0050                     WIDTH_SCREEN EQU 50H
                                
                                ;;; Ascii code Constants
       000D                     CR  EQU 0DH
       000A                     LF  EQU 0AH
       0008                     BS  EQU 08H
       007F                     DEL EQU 7FH
                                
                                
                                ;;; Keyboard scan buffer
                                ;;; キーボードスキャンの実装上、末尾のアドレスが00であることが条件になっている。
       FE00                     KEYBOARD_SCAN_BUFFER EQU 0FE00H
                                
                                
                                ;
                                ;*****************************************************
                                ;*                                                   *
                                ;*         CP/M to host disk constants               *
                                ;*                                                   *
                                ;*****************************************************
       0800                     blksiz equ 2048 ;CP/M allocation size
       0100                     hstsiz equ 256  ;host disk sector size
       001A                     hstspt equ 26   ;host disk sectors/trk
       0002                     hstblk equ hstsiz/128   ;CP/M sects/host buff
       0034                     cpmspt equ hstblk * hstspt  ;CP/M sectors/track
       0001                     secmsk equ hstblk-1 ;sector mask
                                ;smask  hstblk  ;compute sector mask
       0001                     secshf equ 1    ;log2(hstblk)
                                ;
                                ;*****************************************************
                                ;*                                                   *
                                ;*        BDOS constants on entry to write           *
                                ;*                                                   *
                                ;*****************************************************
       0000                     wrall equ 0 ;write to allocated
       0001                     wrdir equ 1 ;write to directory
       0002                     wrual equ 2 ;write to unallocated
                                
000000 F200                             ORG BIOS    ;origin of this program
       002C                     nsects  EQU ($-CCP)/128 ;warm start sector count
                                ;
                                ;   jump vector for individual subroutines
                                ;
000000 F200 C382F2          10          JP  boot    ;cold start
000003 F203 C3A5F2          10  wboote: JP  wboot   ;warm start
000006 F206 C31EF3          10          JP  const   ;console status
000009 F209 C321F3          10          JP  conin   ;console character in
00000C F20C C325F3          10          JP  conout  ;console character out
00000F F20F C32AF3          10          JP  list    ;list character out
000012 F212 C32EF3          10          JP  punch   ;punch character out
000015 F215 C330F3          10          JP  reader  ;reader character out
000018 F218 C335F3          10          JP  home    ;move head to home position
00001B F21B C340F3          10          JP  seldsk  ;select disk
00001E F21E C363F3          10          JP  settrk  ;set track number
000021 F221 C369F3          10          JP  setsec  ;set sector number
000024 F224 C371F3          10          JP  setdma  ;set dma address
000027 F227 C377F3          10          JP  read    ;read disk
00002A F22A C38BF3          10          JP  write   ;write disk
00002D F22D C32CF3          10          JP  listst  ;return list status
000030 F230 C36EF3          10          JP  sectran ;sector translate
                                ;
                                ;   fixed data tables for four-drive standard
                                ;   ibm-compatible 8" disks
                                ;
                                ;   disk Parameter header for disk 00
000033 F233 00000000            dpbase: dw  XLT0, 0000h
000037 F237 00000000                    dw  0000h, 0000h
00003B F23B 3FFC73F2                    dw  dirbf, dpblk
00003F F23F 3BFDBFFC                    dw  chk00, all00
                                ;   disk parameter header for disk 01
000043 F243 00000000                    dw  XLT0, 0000h
000047 F247 00000000                    dw  0000h, 0000h
00004B F24B 3FFC73F2                    dw  dirbf, dpblk
00004F F24F 4BFDDEFC                    dw  chk01, all01
                                ;   disk parameter header for disk 02
000053 F253 00000000                    dw  XLT0, 0000h
000057 F257 00000000                    dw  0000h, 0000h
00005B F25B 3FFC73F2                    dw  dirbf, dpblk
00005F F25F 5BFDFDFC                    dw  chk02, all02
                                ;   disk parameter header for disk 03
000063 F263 00000000                    dw  XLT0, 0000h
000067 F267 00000000                    dw  0000h, 0000h
00006B F26B 3FFC73F2                    dw  dirbf, dpblk
00006F F26F 6BFD1CFD                    dw  chk03, all03
                                ;
                                ;   sector translate vector
       0000                     XLT0    EQU 0       ;NO XLATE TABLE
                                
                                ;
                                ; SORD M68 2HD 77 track, 26 sector, 256 byte/sector, 2side, 4096 data block
                                ;
                                ;
       F273                     dpblk:  ;DISK PARM BLOCK
000073 F273 3400                        DW  52      ;SEC PER TRACK
000075 F275 05                          DB  5       ;BLOCK SHIFT
000076 F276 1F                          DB  31      ;BLOCK MASK
000077 F277 03                          DB  3       ;EXTNT MASK
000078 F278 F200                        DW  242     ;DISK SIZE-1
00007A F27A 7F00                        DW  127     ;DIRECTORY MAX
00007C F27C 80                          DB  128     ;ALLOC0
00007D F27D 00                          DB  0       ;ALLOC1
00007E F27E 2000                        DW  32      ;CHECK SIZE
000080 F280 0200                        DW  2       ;OFFSET
                                ;
                                ;   end of fixed tables
                                ;
                                ;   individual subroutines to perform each function
       F282                     boot:   ;simplest case is to just perform parameter initialization
000082 F282 AF               4          XOR A   ;zero in the accum
000083 F283 320300          13          LD  (iobyte),A  ;clear the iobyte
000086 F286 320400          13          LD  (cdisk),A   ;select disk zero
000089 F289 322BFB          13          LD  (hstact),A  ;host buffer inactive
00008C F28C 322DFB          13          LD  (unacnt),A  ;clear unalloc count
00008F F28F CDB2F5          17          CALL SIO_INIT
000092 F292 CD67F6          17          CALL CRT_INIT
000095 F295 CD54F6          17          CALL KBD_INIT
000098 F298 F5              11          PUSH AF
000099 F299 E5              11          PUSH HL
00009A F29A 2125F6          10          LD HL,OPENMSG
00009D F29D CDD8F5          17          CALL STROUT
0000A0 F2A0 E1              10          POP HL
0000A1 F2A1 F1              10          POP AF
0000A2 F2A2 C3FCF2          10          JP  gocpm   ;initialize and go to cp/m
                                ;
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; worm boot process
                                ;
       F2A5                     wboot:  ;simplest case is to read the disk until all sectors loaded
                                
                                        ; WBOOTでは、CPPとBDOSをディスクから再ロードする。
                                        ; BIOSはロードしない（すると壊れる）。
                                
0000A5 F2A5 3180FF          10          LD  SP, FF80h   ;use space below buffer for stack
0000A8 F2A8 0E00             7          LD  C, 0    ;select disk 0
0000AA F2AA CD40F3          17          CALL seldsk
0000AD F2AD CD01F5          17          CALL RESTORE ; HEAD move to track 00
                                
                                        ; FDC initialize
0000B0 F2B0 3E04             7          LD A,04H ; 
0000B2 F2B2 CDACF5          17          CALL FDC_CONTROL_OUT
                                
                                        ; DMA Bank Selectを0に設定
0000B5 F2B5 AF               4          XOR A ; A=0
0000B6 F2B6 D3CE            11          OUT (DMA_BANK_SEL), A
                                
                                        ; DMAの転送アドレスを62k memory modelにおけるccpのアドレス(DC00H)にセットする。
                                
0000B8 F2B8 3EDC             7          LD A,0DCH ; DC00Hは62K memory model
0000BA F2BA 3221F6          13          LD (wboot_add),A
                                
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; 1st READ
                                        ; 現在は、トラック7、Side 0、セクタ13～26からトラック7、Side 1、セクタ1～18という
                                        ; 中途半端な位置にCPM.SYSを配置している。wbootではBIOSを除いた1600H分読み込むこと。つまり22セクタ分
                                        ;
0000BD F2BD 1604             7          LD D,04H
0000BF F2BF 1E07             7          LD E,07H ; TARGET TRACK is No.7
       F2C1                     DO_SEEK_WBOOT0:
0000C1 F2C1 CD14F5          17          CALL SEEK
0000C4 F2C4 2802            12          JR Z,GO_DMA_WBOOT0
0000C6 F2C6 18F9            12          JR DO_SEEK_WBOOT0
       F2C8                     GO_DMA_WBOOT0:
0000C8 F2C8 060E             7          LD B,14 ; LOOP COUNT is 0EH(14) sectors
0000CA F2CA 1604             7          LD D,04H ; FDCCONTROL COMMAND is Side 0 & High density mode
0000CC F2CC 0E0D             7          LD C,13 ; INITIAL SECTOR NO. is 0DH(13) to 26 sector reading
                                ;
       F2CE                     READ_LOOP_WBOOT0:
0000CE F2CE CD8AF5          17          CALL GO_DMA_AND_READ_WBOOT0
0000D1 F2D1 0C               4          INC C
0000D2 F2D2 3A21F6          13          LD A,(wboot_add) ; memory address of DMA transfer address
0000D5 F2D5 3C               4          INC A ; 256 byte incriment
0000D6 F2D6 3221F6          13          LD (wboot_add),A
0000D9 F2D9 10F3            13          DJNZ READ_LOOP_WBOOT0
                                
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; 2nd READ
                                        ;
                                        ;
                                        ; SEEK
                                        ;
0000DB F2DB 1E07             7          LD E,07H  ; TARGET TRACK No.7
                                        ; FDC \DDENS setting
0000DD F2DD 1624             7          LD D,24H ; Side 1 & High density mode
                                    ;   LD D,4H ; Side 0 & High density mode
                                    ;   LD D,44H ; Side 0 & LOW density mode
                                    ;
                                
       F2DF                     DO_SEEK_WBOOT1:
0000DF F2DF CD14F5          17          CALL SEEK
0000E2 F2E2 2802            12          JR Z,GO_DMA_WBOOT1
0000E4 F2E4 18F9            12          JR DO_SEEK_WBOOT1
       F2E6                     GO_DMA_WBOOT1:
0000E6 F2E6 1624             7          LD D,24H ; FDCCONTROL COMMAND is side 1 & High density mode
0000E8 F2E8 0E01             7          LD C,01 ; INITIAL SECTOR NO. is 1 to 08H(8) sector reading. total 22 sector read.
0000EA F2EA 0608             7          LD B,08 ; LOOP COUNT is 08H(8) sectors
                                ;
       F2EC                     READ_LOOP_WBOOT1:
0000EC F2EC CD9BF5          17          CALL GO_DMA_AND_READ_WBOOT1
0000EF F2EF 0C               4          INC C
0000F0 F2F0 3A21F6          13          LD A,(wboot_add) ; memory address of DMA transfer address
0000F3 F2F3 3C               4          INC A ; 256 byte incriment
0000F4 F2F4 3221F6          13          LD (wboot_add),A
0000F7 F2F7 10F3            13          DJNZ READ_LOOP_WBOOT1
                                
0000F9 F2F9 C3FCF2          10          JP gocpm ; CP/Mを再起動
                                
                                ; wboot:    ;simplest case is to read the disk until all sectors loaded
                                ;       LD  SP, 80h ;use space below buffer for stack
                                ;       LD  C, 0    ;select disk 0
                                ;       CALL    seldsk
                                ;       CALL    home    ;go to track 00
                                ; ;
                                ;       LD  B, nsects   ;b counts * of sectors to load
                                ;       LD  C, 0    ;c has the current track number
                                ;       LD  D, 2    ;d has the next sector to read
                                ; ; note that we begin by reading track 0, sector 2 since sector 1
                                ; ; contains the cold start loader, which is skipped in a warm start
                                ;       LD  HL, ccp ;base of cp/m (initial load point)
                                ; load1:    ;load   one more sector
                                ;       PUSH    BC  ;save sector count, current track
                                ;       PUSH    DE  ;save next sector to read
                                ;       PUSH    HL  ;save dma address
                                ;       LD  C, D    ;get sector address to register C
                                ;       CALL    setsec  ;set sector address from register C
                                ;       POP BC  ;recall dma address to b, C
                                ;       PUSH    BC  ;replace on stack for later recall
                                ;       CALL    setdma  ;set dma address from b, C
                                ; ;
                                ; ; drive set to 0, track set, sector set, dma address set
                                ;       CALL    read
                                ;       CP  00h ;any errors?
                                ;       JP  NZ,wboot    ;retry the entire boot if an error occurs
                                ; ;
                                ; ; no error, move to next sector
                                ;       POP HL  ;recall dma address
                                ;       LD  DE, 128 ;dma=dma+128
                                ;       ADD HL,DE   ;new dma address is in h, l
                                ;       POP DE  ;recall sector address
                                ;       POP BC  ;recall number of sectors remaining, and current trk
                                ;       DEC B   ;sectors=sectors-1
                                ;       JP  Z,gocpm ;transfer to cp/m if all have been loaded
                                ; ;
                                ; ; more    sectors remain to load, check for track change
                                ;       INC D
                                ;       LD  A,D ;sector=27?, if so, change tracks
                                ;       CP  27
                                ;       JP  C,load1 ;carry generated if sector<27
                                ; ;
                                ; ; end of  current track,  go to next track
                                ;       LD  D, 1    ;begin with first sector of next track
                                ;       INC C   ;track=track+1
                                ; ;
                                ; ; save    register state, and change tracks
                                ;       PUSH    BC
                                ;       PUSH    DE
                                ;       PUSH    HL
                                ;       CALL    settrk  ;track address set from register c
                                ;       POP HL
                                ;       POP DE
                                ;       POP BC
                                ;       JP  load1   ;for another sector
                                ;
                                ;   end of  load operation, set parameters and go to cp/m
       F2FC                     gocpm:
0000FC F2FC 3EC3             7          LD  A, 0c3h ;c3 is a jmp instruction
0000FE F2FE 320000          13          LD  (0),A   ;for jmp to wboot
000101 F301 2103F2          10          LD  HL, wboote  ;wboot entry point
000104 F304 220100          16          LD  (1),HL  ;set address field for jmp at 0
                                ;
000107 F307 320500          13          LD  (5),A   ;for jmp to bdos
00010A F30A 2106E4          10          LD  HL, bdos    ;bdos entry point
00010D F30D 220600          16          LD  (6),HL  ;address field of Jump at 5 to bdos
                                ;
000110 F310 018000          10          LD  BC, 80h ;default dma address is 80h
000113 F313 CD71F3          17          CALL    setdma
000116 F316 FB               4          EI  ;enable the interrupt system
000117 F317 3A0400          13          LD  A,(cdisk)   ;get current disk number
00011A F31A 4F               4          LD  C, A    ;send to the ccp
00011B F31B C300DC          10          JP  ccp ;go to cp/m for further processing
                                ;
                                ;
                                ;   simple i/o handlers (must be filled in by user)
                                ;   in each case, the entry point is provided, with space reserved
                                ;   to insert your own code
                                ;
       F31E                     const:  ;console status, return 0ffh if character ready, 00h if not
00011E F31E 3E00             7          LD A,0H
000120 F320 C9              10          RET
                                ;
       F321                     conin:  ;console character into register a
000121 F321 CD55F8          17          CALL KEY_SCAN_LAP
000124 F324 C9              10          RET
                                ;
       F325                     conout: ;console character output from register c
000125 F325 79               4          LD A,C
000126 F326 CDAFF6          17          CALL PUTCHAR
000129 F329 C9              10          RET
                                ;
       F32A                     list:   ;list character from register c
00012A F32A 79               4          LD  A, C    ;character to register a
00012B F32B C9              10          RET ;null subroutine
                                ;
       F32C                     listst: ;return list status (0 if not ready, 1 if ready)
00012C F32C AF               4          XOR A   ;0 is always ok to return
00012D F32D C9              10          RET
                                ;
       F32E                     punch:  ;punch  character from  register C
00012E F32E 79               4          LD  A, C    ;character to register a
00012F F32F C9              10          RET ;null subroutine
                                ;
                                ;
       F330                     reader: ;reader character into register a from reader device
000130 F330 3E1A             7          LD  A, 1ah  ;enter end of file for now (replace later)
000132 F332 E67F             7          AND 7fh ;remember to strip parity bit
000134 F334 C9              10          RET
                                ;
                                ;
                                ;   i/o drivers for the disk follow
                                ;   for now, we will simply store the parameters away for use
                                ;   in the read and write   subroutines
                                ;
       F335                     home:   ;move to the track 00   position of current drive
                                ;   translate this call into a settrk call with Parameter 00
000135 F335 3A2CFB          13          LD  A,(hstwrt)  ;check for pending write
000138 F338 B7               4          OR  A
000139 F339 C23FF3          10          JP  NZ,homed
00013C F33C 322BFB          13          LD  (hstact),A  ;clear host active flag
       F33F                     homed:
00013F F33F C9              10          RET ;we will move to 00 on first read/write
                                ;
       F340                     seldsk: ;select disk given by register c
000140 F340 210000          10          LD  HL, 0000h   ;error return code
000143 F343 79               4          LD  A, C ; cはドライブ番号
000144 F344 3222FB          13          LD  (sekdsk), A ; seek disk number
000147 F347 FE04             7          CP  4   ;must be between 0 and 3
000149 F349 D0              11          RET NC  ;no carry if 4, 5,...
                                ;   disk number is in the proper range
00014A F34A C604             7          ADD  A, 4 ; 第3ビットを1にして、ドライブをイネーブルにする。
00014C F34C 47               4          LD  B, A ; 第3ビットを立てたdrive numberをBにコピー
00014D F34D 3A10FE          13          LD A, (fdc_control_command) ; 直近に発行したfdc control commandをAにコピー
000150 F350 E6F8             7          AND 0F8H ; 下位3ビットをクリア。
000152 F352 B0               4          OR  B ; 保存している下位3ビットと新しい上位5ビットを結合してfdc control commandを作る
000153 F353 CDACF5          17          CALL FDC_CONTROL_OUT
000156 F356 79               4          LD A,C ; 今後の処理のために、もう一度、ドライブ番号をAに入れる。
                                
                                ;       DS  10  ;space for disk select
                                ;   compute proper disk Parameter header address
                                ;       LD  A,(diskno)
000157 F357 6F               4          LD  L, A    ;l=disk number 0, 1, 2, 3
000158 F358 2600             7          LD  H, 0    ;high order zero
00015A F35A 29              11          ADD HL,HL   ;*2
00015B F35B 29              11          ADD HL,HL   ;*4
00015C F35C 29              11          ADD HL,HL   ;*8
00015D F35D 29              11          ADD HL,HL   ;*16 (size of each header)
00015E F35E 1133F2          10          LD  DE, dpbase ;base of parm block
000161 F361 19              11          ADD HL,DE   ;hl=,dpbase (diskno*16)(curdsk)
000162 F362 C9              10          RET
                                ;
       F363                     settrk:
                                    ;set track given by registers BC
000163 F363 60               4          LD  H,B
000164 F364 69               4          LD  L,C
000165 F365 2223FB          16          LD  (sektrk),HL ;track to seek
000168 F368 C9              10          RET
                                ;
       F369                     setsec: ;set sector given by register c
000169 F369 79               4          LD  A, C
00016A F36A 3225FB          13          LD  (seksec),A
00016D F36D C9              10          RET
                                ;
                                ;
       F36E                     sectran:
                                    ;translate sector number BC
00016E F36E 60               4          LD  H,B
00016F F36F 69               4          LD  L,C
000170 F370 C9              10          RET
                                
                                ;
       F371                     setdma: ;set    dma address given by registers b and c
000171 F371 69               4          LD  L, C    ;low order address
000172 F372 60               4          LD  H, B    ;high order address
000173 F373 2236FB          16          LD  (dmaadr),HL ;save the address
000176 F376 C9              10          RET
                                ;
                                ;
                                ;*****************************************************
                                ;*                                                   *
                                ;*  The READ entry point takes the place of      *
                                ;*  the previous BIOS defintion for READ.        *
                                ;*                                                   *
                                ;*****************************************************
       F377                     read:
                                    ;read the selected CP/M sector
000177 F377 AF               4          XOR A
000178 F378 322DFB          13          LD  (unacnt),A
00017B F37B 3E01             7          LD  A,1
00017D F37D 3234FB          13          LD  (readop),A  ;read operation
000180 F380 3233FB          13          LD  (rsflag),A  ;must read data
000183 F383 3E02             7          LD  A,wrual
000185 F385 3235FB          13          LD  (wrtype),A  ;treat as unalloc
000188 F388 C3F6F3          10          JP  rwoper  ;to perform the read
                                ;
                                ;
                                ;*****************************************************
                                ;*                                                   *
                                ;*  The WRITE entry point takes the place of     *
                                ;*  the previous BIOS defintion for WRITE.       *
                                ;*                                                   *
                                ;*****************************************************
       F38B                     write:
                                    ;write the selected CP/M sector
00018B F38B AF               4          XOR A   ;0 to accumulator
00018C F38C 3234FB          13          LD  (readop),A  ;not a read operation
00018F F38F 79               4          LD  A,C ;write type in c
000190 F390 3235FB          13          LD  (wrtype),A
000193 F393 FE02             7          CP  wrual   ;write unallocated?
000195 F395 C2AFF3          10          JP  NZ,chkuna   ;check for unalloc
                                ;
                                ;   write to unallocated, set parameters
000198 F398 3E10             7          LD  A,blksiz/128    ;next unalloc recs
00019A F39A 322DFB          13          LD  (unacnt),A
00019D F39D 3A22FB          13          LD  A,(sekdsk)  ;disk to seek
0001A0 F3A0 322EFB          13          LD  (unadsk),A  ;unadsk = sekdsk
0001A3 F3A3 2A23FB          16          LD  HL,(sektrk)
0001A6 F3A6 222FFB          16          LD  (unatrk),HL ;unatrk = sectrk
0001A9 F3A9 3A25FB          13          LD  A,(seksec)
0001AC F3AC 3231FB          13          LD  (unasec),A  ;unasec = seksec
                                ;
       F3AF                     chkuna:
                                    ;check for write to unallocated sector
0001AF F3AF 3A2DFB          13          LD  A,(unacnt)  ;any unalloc remain?
0001B2 F3B2 B7               4          OR  A
0001B3 F3B3 CAEEF3          10          JP  Z,alloc ;skip if not
                                ;
                                ;   more unallocated records remain
0001B6 F3B6 3D               4          DEC A   ;unacnt = unacnt-1
0001B7 F3B7 322DFB          13          LD  (unacnt),A
0001BA F3BA 3A22FB          13          LD  A,(sekdsk)  ;same disk?
0001BD F3BD 212EFB          10          LD  HL,unadsk
0001C0 F3C0 BE               7          CP  (HL)    ;sekdsk = unadsk?
0001C1 F3C1 C2EEF3          10          JP  NZ,alloc    ;skip if not
                                ;
                                ;   disks are the same
0001C4 F3C4 212FFB          10          LD  HL,unatrk
0001C7 F3C7 CD91F4          17          CALL    sektrkcmp   ;sektrk = unatrk?
0001CA F3CA C2EEF3          10          JP  NZ,alloc    ;skip if not
                                ;
                                ;   tracks are the same
0001CD F3CD 3A25FB          13          LD  A,(seksec)  ;same sector?
0001D0 F3D0 2131FB          10          LD  HL,unasec
0001D3 F3D3 BE               7          CP  (HL)    ;seksec = unasec?
0001D4 F3D4 C2EEF3          10          JP  NZ,alloc    ;skip if not
                                ;
                                ;   match, move to next sector for future ref
0001D7 F3D7 34              11          INC (HL)    ;unasec = unasec+1
0001D8 F3D8 7E               7          LD  A,(HL)  ;end of track?
0001D9 F3D9 FE34             7          CP  cpmspt  ;count CP/M sectors
0001DB F3DB DAE7F3          10          JP  C,noovf ;skip if no overflow
                                ;
                                ;   overflow to next track
0001DE F3DE 3600            10          LD  (HL),0  ;unasec = 0
0001E0 F3E0 2A2FFB          16          LD  HL,(unatrk)
0001E3 F3E3 23               6          INC HL
0001E4 F3E4 222FFB          16          LD  (unatrk),HL ;unatrk = unatrk+1
                                ;
       F3E7                     noovf:
                                    ;match found, mark as unnecessary read
0001E7 F3E7 AF               4          XOR A   ;0 to accumulator
0001E8 F3E8 3233FB          13          LD  (rsflag),A  ;rsflag = 0
0001EB F3EB C3F6F3          10          JP  rwoper  ;to perform the write
                                ;
       F3EE                     alloc:
                                    ;not an unallocated record, requires pre-read
0001EE F3EE AF               4          XOR A   ;0 to accum
0001EF F3EF 322DFB          13          LD  (unacnt),A  ;unacnt = 0
0001F2 F3F2 3C               4          INC A   ;1 to accum
0001F3 F3F3 3233FB          13          LD  (rsflag),A  ;rsflag = 1
                                ;
                                ;*****************************************************
                                ;*                                                   *
                                ;*  Common code for READ and WRITE follows           *
                                ;*                                                   *
                                ;*****************************************************
       F3F6                     rwoper:
                                    ;enter here to perform the read/write
0001F6 F3F6 AF               4          XOR A   ;zero to accum
0001F7 F3F7 3232FB          13          LD  (erflag),A  ;no errors (yet)
0001FA F3FA 3A25FB          13          LD  A,(seksec)  ;compute host sector
0001FD F3FD B7               4          OR  A   ;carry = 0
0001FE F3FE 1F               4          RRA ;shift right
0001FF F3FF 322AFB          13          LD  (sekhst),A  ;host sector to seek
                                ;
                                ;   active host sector?
000202 F402 212BFB          10          LD  HL,hstact   ;host active flag
000205 F405 7E               7          LD  A,(HL)
000206 F406 3601            10          LD  (HL),1  ;always becomes 1
000208 F408 B7               4          OR  A   ;was it already?
000209 F409 CA30F4          10          JP  Z,filhst    ;fill host if not
                                ;
                                ;   host buffer active, same as seek buffer?
00020C F40C 3A22FB          13          LD  A,(sekdsk)
00020F F40F 2126FB          10          LD  HL,hstdsk   ;same disk?
000212 F412 BE               7          CP  (HL)    ;sekdsk = hstdsk?
000213 F413 C229F4          10          JP  NZ,nomatch
                                ;
                                ;   same disk, same track?
000216 F416 2127FB          10          LD  HL,hsttrk
000219 F419 CD91F4          17          CALL sektrkcmp  ;sektrk = hsttrk?
00021C F41C C229F4          10          JP  NZ,nomatch
                                ;
                                ;   same disk, same track, same buffer?
00021F F41F 3A2AFB          13          LD  A,(sekhst)
000222 F422 2129FB          10          LD  HL,hstsec   ;sekhst = hstsec?
000225 F425 BE               7          CP  (HL)
000226 F426 CA4DF4          10          JP  Z,match ;skip if match
                                ;
       F429                     nomatch:
                                    ;proper disk, but not correct sector
000229 F429 3A2CFB          13          LD  A,(hstwrt)  ;host written?
00022C F42C B7               4          OR  A
00022D F42D C49DF4          17          CALL    NZ,writehst ;clear host buff
                                ;
       F430                     filhst:
                                    ;may have to fill the host buffer
000230 F430 3A22FB          13          LD  A,(sekdsk)
000233 F433 3226FB          13          LD  (hstdsk),A
000236 F436 2A23FB          16          LD  HL,(sektrk)
000239 F439 2227FB          16          LD  (hsttrk),HL
00023C F43C 3A2AFB          13          LD  A,(sekhst)
00023F F43F 3229FB          13          LD  (hstsec),A
000242 F442 3A33FB          13          LD  A,(rsflag)  ;need to read?
000245 F445 B7               4          OR  A
000246 F446 C4C8F4          17          CALL NZ,readhst ;yes, if 1
000249 F449 AF               4          XOR A   ;0 to accum
00024A F44A 322CFB          13          LD  (hstwrt),A  ;no pending write
                                ;
       F44D                     match:
                                    ;copy data to or from buffer
00024D F44D 3A25FB          13          LD  A,(seksec)  ;mask buffer number
000250 F450 E601             7          AND secmsk  ;least signif bits
000252 F452 6F               4          LD  L,A ;ready to shift
000253 F453 2600             7          LD  H,0 ;double count
000255 F455 29              11          ADD HL,HL
000256 F456 29              11          ADD HL,HL
000257 F457 29              11          ADD HL,HL
000258 F458 29              11          ADD HL,HL
000259 F459 29              11          ADD HL,HL
00025A F45A 29              11          ADD HL,HL
00025B F45B 29              11          ADD HL,HL
                                ;   hl has relative host buffer address
00025C F45C 1138FB          10          LD  DE,hstbuf
00025F F45F 19              11          ADD HL,DE   ;hl = host address
000260 F460 EB               4          EX  DE,HL   ;now in DE
000261 F461 2A36FB          16          LD  HL,(dmaadr) ;get/put CP/M data
                                ;       LD  C,128   ;length of move
000264 F464 0E80             7          LD  C,80H   ;length of move
000266 F466 3A34FB          13          LD  A,(readop)  ;which way?
000269 F469 B7               4          OR  A
00026A F46A C273F4          10          JP  NZ,rwmove   ;skip if read
                                ;
                                ;   write operation, mark and switch direction
00026D F46D 3E01             7          LD  A,1
00026F F46F 322CFB          13          LD  (hstwrt),A  ;hstwrt = 1
000272 F472 EB               4          EX  DE,HL   ;source/dest swap
                                ;
       F473                     rwmove:
                                    ;C initially 128(80H), DE is source, HL is dest
000273 F473 1A               7          LD  A,(DE)  ;source character
000274 F474 13               6          INC DE
000275 F475 77               7          LD  (HL),A  ;to dest
000276 F476 23               6          INC HL
000277 F477 0D               4          DEC C   ;loop 128 times
000278 F478 C273F4          10          JP  NZ,rwmove
                                ;
                                ;   data has been moved to/from host buffer
00027B F47B 3A35FB          13          LD  A,(wrtype)  ;write type
00027E F47E FE01             7          CP  wrdir   ;to directory?
000280 F480 3A32FB          13          LD  A,(erflag)  ;in case of errors
000283 F483 C0              11          RET NZ  ;no further processing
                                ;
                                ;   clear host buffer for directory write
000284 F484 B7               4          OR  A   ;errors?
000285 F485 C0              11          RET NZ  ;skip if so
000286 F486 AF               4          XOR A   ;0 to accum
000287 F487 322CFB          13          LD  (hstwrt),A  ;buffer written
00028A F48A CD9DF4          17          CALL    writehst
00028D F48D 3A32FB          13          LD  A,(erflag)
000290 F490 C9              10          RET
                                ;
                                ;
                                ;*****************************************************
                                ;*                                                   *
                                ;*  Utility subroutine for 16-bit compare        *
                                ;*                                                   *
                                ;*****************************************************
       F491                     sektrkcmp:
                                    ;HL = .unatrk or .hsttrk, compare with sektrk
000291 F491 EB               4          EX  DE,HL
000292 F492 2123FB          10          LD  HL,sektrk
000295 F495 1A               7          LD  A,(DE)  ;low byte compare
000296 F496 BE               7          CP  (HL)    ;same?
000297 F497 C0              11          RET NZ  ;return if not
                                ;   low bytes equal, test high 1s
000298 F498 13               6          INC DE
000299 F499 23               6          INC HL
00029A F49A 1A               7          LD  A,(DE)
00029B F49B BE               7          CP  (HL)    ;sets flags
00029C F49C C9              10          RET
                                ;
                                ;
                                ;*****************************************************
                                ;*                                                   *
                                ;*  WRITEHST performs the physical write to      *
                                ;*  the host disk, READHST reads the physical    *
                                ;*  disk.                        *
                                ;*                                                   *
                                ;*****************************************************
       F49D                     writehst:
                                    ;hstdsk = host disk #, hsttrk = host track #,
                                    ;hstsec = host sect #. write "hstsiz" bytes
                                    ;from hstbuf and return error flag in erflag.
                                    ;return erflag non-zero if error
00029D F49D 3A27FB          13          LD A,(hsttrk)
0002A0 F4A0 CB3F             8          SRL A
0002A2 F4A2 3804            12          JR C,SET_WRT_SIDE1
       F4A4                     SET_WRT_SIDE0: ; TRACK NO. IS EVEN --> SIDE 0
0002A4 F4A4 1604             7          LD D,4H
0002A6 F4A6 1802            12          JR WRT_CONTINUE
       F4A8                     SET_WRT_SIDE1: ; TRACK NO. IS ODD --> SIDE 1
0002A8 F4A8 1624             7          LD D,24H
       F4AA                     WRT_CONTINUE:
0002AA F4AA C601             7          ADD A,01H
0002AC F4AC 5F               4          LD E,A ; E is Track No.
0002AD F4AD CD14F5          17          CALL SEEK
0002B0 F4B0 3A29FB          13          LD A,(hstsec)
0002B3 F4B3 C601             7          ADD A,01H
0002B5 F4B5 4F               4          LD C,A ; C is Sector No.
0002B6 F4B6 CB6A             8          BIT 5,D ; BIT IS 1 THEN SIDE 1. IS 0 THEN SIDE 0.
0002B8 F4B8 2005            12          JR NZ,WRITE_SIDE1
       F4BA                     WRITE_SIDE0:
0002BA F4BA CD5CF5          17          CALL GO_DMA_AND_WRITE0
0002BD F4BD 1803            12          JR WRITE_END
       F4BF                     WRITE_SIDE1:
0002BF F4BF CD73F5          17          CALL GO_DMA_AND_WRITE1
       F4C2                     WRITE_END:
0002C2 F4C2 3E00             7          LD A,0 ; allways SUCCESS
0002C4 F4C4 3232FB          13          LD (erflag),A
0002C7 F4C7 C9              10          RET
                                ;
       F4C8                     readhst:
                                    ;hstdsk = host disk #, hsttrk = host track #,
                                    ;hstsec = host sect #. read "hstsiz" bytes
                                    ;into hstbuf and return error flag in erflag.
0002C8 F4C8 3A27FB          13          LD A,(hsttrk)
0002CB F4CB CB3F             8          SRL A
0002CD F4CD 3804            12          JR C,SET_RD_SIDE1
       F4CF                     SET_RD_SIDE0: ; TRACK NO. IS EVEN ---> SIDE 0
0002CF F4CF 1604             7          LD D,4H
0002D1 F4D1 1802            12          JR READ_CONTINUE
       F4D3                     SET_RD_SIDE1: ; TRACK NO. IS ODD ---> SIDE 1
0002D3 F4D3 1624             7          LD D,24H
       F4D5                     READ_CONTINUE:
0002D5 F4D5 C601             7          ADD A,01H
0002D7 F4D7 5F               4          LD E,A ; E is Track No.
0002D8 F4D8 CD14F5          17          CALL SEEK
0002DB F4DB 3A29FB          13          LD A,(hstsec)
0002DE F4DE C601             7          ADD A,01H
0002E0 F4E0 4F               4          LD C,A ; C is Sector No.
0002E1 F4E1 CB6A             8          BIT 5,D ; BIT IS 1 THEN SIDE 1. IS 0 THEN SIDE 0.
0002E3 F4E3 2005            12          JR NZ,READ_SIDE1
       F4E5                     READ_SIDE0:
0002E5 F4E5 CD2EF5          17          CALL GO_DMA_AND_READ0
0002E8 F4E8 1803            12          JR READ_END
       F4EA                     READ_SIDE1:
0002EA F4EA CD45F5          17          CALL GO_DMA_AND_READ1
       F4ED                     READ_END:
0002ED F4ED 3E00             7          LD A,0 ; allways SUCCESS
0002EF F4EF 3232FB          13          LD (erflag),A
0002F2 F4F2 C9              10          RET
                                ;
                                ; FDC COMMAND OUT subroutine
                                ;
       F4F3                     FDCOUT:
0002F3 F4F3 D3C8            11      OUT (FDC_COMMAND_REG),A
0002F5 F4F5 3E30             7      LD A,30H
0002F7 F4F7 3D               4  WLOOP: DEC A
0002F8 F4F8 20FD            12      JR NZ,WLOOP
       F4FA                     LOOP2:
0002FA F4FA DBC8            11      IN A,(FDC_STATUS_REG)
0002FC F4FC CB47             8      BIT 0,A ; BUSY IS CLEAR?
0002FE F4FE 20FA            12      JR NZ,LOOP2
000300 F500 C9              10      RET
                                ;
                                ; RESTORE subroutine
                                ;
       F501                     RESTORE:
       F501                     RESTORE_LOOP:
000301 F501 3E44             7      LD A,44H ;  \DDENS is HIGH. Single density mode. 
000303 F503 CDACF5          17      CALL FDC_CONTROL_OUT
                                
000306 F506 3E0C             7      LD A,0CH ; restore command
000308 F508 CDF3F4          17      CALL FDCOUT
00030B F50B CB7F             8      BIT 7,A ; Not Ready?
00030D F50D 20F2            12      JR NZ,RESTORE_LOOP
00030F F50F E698             7      AND 98H
000311 F511 20EE            12      JR NZ,RESTORE
000313 F513 C9              10      RET
                                ;
                                ; SEEK subroutine
                                ; D is fdccontrol COMMAND
                                ; if D=0x44 : \DDEN is HIGH. Single density mode. 
                                ; if D=0x4  : \DDEN is LOW. Double density mode. 
                                ; if D=0x24 : Side 1 and Double density mode.
                                ; E is Track No.
                                ;
       F514                     SEEK:
000314 F514 7A               4      LD A,D ; D is control command.
000315 F515 CDACF5          17      CALL FDC_CONTROL_OUT
                                
000318 F518 7B               4      LD A,E
000319 F519 D3CB            11      OUT (FDC_DATA_REG),A
00031B F51B 3E1C             7      LD A,1CH ; SEEK COMMAND
00031D F51D CDF3F4          17      CALL FDCOUT
000320 F520 E698             7      AND 98H
000322 F522 C9              10      RET
                                ;
                                ; DMA setting & Go
                                ; HL is Address of DMA Command chain
                                ;       but top value is No of DMA Command chain
       F523                     DMA_ON:
000323 F523 E5              11      PUSH HL
000324 F524 C5              11      PUSH BC
000325 F525 46               7      LD B,(HL)
000326 F526 23               6      INC HL
000327 F527 0ECC             7      LD C,DMA_ADDRESS
000329 F529 EDB3                    OTIR
00032B F52B C1              10      POP BC
00032C F52C E1              10      POP HL
00032D F52D C9              10      RET
                                ;
                                ; DMA setting & FDD read FOR SIDE 0
                                ; C is Sector No.
                                ; D is Control word.
                                ; if D=0x44 : \DDEN is HIGH. Low density mode. 
                                ; if D=0x4  : \DDEN is LOW. High density mode. 
                                ; if D=0x24 : Side 1 and High density mode.
                                ;
       F52E                     GO_DMA_AND_READ0:
00032E F52E 79               4      LD A,C
00032F F52F D3CA            11      OUT (FDC_SECTOR_REG),A
000331 F531 7A               4      LD A,D ; D is control command
000332 F532 CDACF5          17      CALL FDC_CONTROL_OUT
                                
000335 F535 21E2F5          10      LD HL,DMA_COMMANDS
000338 F538 CD23F5          17      CALL DMA_ON
00033B F53B E620             7      AND 20H
00033D F53D 3E82             7      LD A,82H ; READ DATA COMMAND for Side 0
       F53F                     DO_FDC0:
00033F F53F CDF3F4          17      CALL FDCOUT
000342 F542 E6FC             7      AND 0FCH
000344 F544 C9              10      RET
                                ;
                                ; DMA setting & FDD read FOR SIDE 1
                                ; C is Sector No.
                                ; D is Control word.
                                ;
       F545                     GO_DMA_AND_READ1:
000345 F545 79               4      LD A,C
000346 F546 D3CA            11      OUT (FDC_SECTOR_REG),A
000348 F548 7A               4      LD A,D ; D is control command
000349 F549 CDACF5          17      CALL FDC_CONTROL_OUT
                                
00034C F54C 21E2F5          10      LD HL,DMA_COMMANDS
00034F F54F CD23F5          17      CALL DMA_ON
000352 F552 E620             7      AND 20H
000354 F554 3E8A             7      LD A,8AH ; READ DATA COMMAND for Side 1
       F556                     DO_FDC1:
000356 F556 CDF3F4          17      CALL FDCOUT
000359 F559 E6FC             7      AND 0FCH
00035B F55B C9              10      RET
                                ;
                                ; DMA setting & FDD write FOR SIDE 0
                                ; C is Sector No.
                                ; D is Control word.
                                ; if D=0x44 : \DDEN is HIGH. Low density mode. 
                                ; if D=0x4  : \DDEN is LOW. High density mode. 
                                ; if D=0x24 : Side 1 and High density mode.
                                ;
       F55C                     GO_DMA_AND_WRITE0:
00035C F55C 79               4      LD A,C
00035D F55D D3CA            11      OUT (FDC_SECTOR_REG),A
00035F F55F 7A               4      LD A,D ; D is control command
000360 F560 CDACF5          17      CALL FDC_CONTROL_OUT
                                
000363 F563 21F8F5          10      LD HL,DMA_WRITE_COMMANDS
000366 F566 CD23F5          17      CALL DMA_ON
000369 F569 E620             7      AND 20H
00036B F56B 3EA2             7      LD A,0A2H ; WRITE DATA COMMAND for Side 0
       F56D                     DO_FDC_WR0:
00036D F56D CDF3F4          17      CALL FDCOUT
000370 F570 E6FC             7      AND 0FCH
000372 F572 C9              10      RET
                                ;
                                ; DMA setting & FDD write FOR SIDE 1
                                ; C is Sector No.
                                ; D is Control word.
                                ;
       F573                     GO_DMA_AND_WRITE1:
000373 F573 79               4      LD A,C
000374 F574 D3CA            11      OUT (FDC_SECTOR_REG),A
000376 F576 7A               4      LD A,D ; D is Control command
000377 F577 CDACF5          17      CALL FDC_CONTROL_OUT
                                
00037A F57A 21F8F5          10      LD HL,DMA_WRITE_COMMANDS
00037D F57D CD23F5          17      CALL DMA_ON
000380 F580 E620             7      AND 20H
000382 F582 3EAA             7      LD A,0AAH ; WRITE DATA COMMAND for Side 1
       F584                     DO_FDC_WR1:
000384 F584 CDF3F4          17      CALL FDCOUT
000387 F587 E6FC             7      AND 0FCH
000389 F589 C9              10      RET
                                
                                ;
                                ; DMA setting & FDD read FOR WBOOT at SIDE 0
                                ; C is Sector No.
                                ;
       F58A                     GO_DMA_AND_READ_WBOOT0:
00038A F58A 79               4      LD A,C
00038B F58B D3CA            11      OUT (FDC_SECTOR_REG),A
00038D F58D 210FF6          10      LD HL,DMA_WBOOT_COMMANDS
000390 F590 CD23F5          17      CALL DMA_ON
000393 F593 3E82             7      LD A,82H ; READ DATA COMMAND for Side 0
                                ;   LD A,8AH ; READ DATA COMMAND for Side 1
000395 F595 CDF3F4          17      CALL FDCOUT
000398 F598 E6FC             7      AND 0FCH
00039A F59A C9              10      RET
                                ;
                                ; DMA setting & FDD read FOR WBOOT at SIDE 1
                                ; C is Sector No.
                                ;
       F59B                     GO_DMA_AND_READ_WBOOT1:
00039B F59B 79               4      LD A,C
00039C F59C D3CA            11      OUT (FDC_SECTOR_REG),A
00039E F59E 210FF6          10      LD HL,DMA_WBOOT_COMMANDS
0003A1 F5A1 CD23F5          17      CALL DMA_ON
                                    ; LD A,82H ; READ DATA COMMAND for Side 0
0003A4 F5A4 3E8A             7      LD A,8AH ; READ DATA COMMAND for Side 1
0003A6 F5A6 CDF3F4          17      CALL FDCOUT
0003A9 F5A9 E6FC             7      AND 0FCH
0003AB F5AB C9              10      RET
                                
                                ;;
                                ; FDC CONTROL_COMMAND OUT subroutine
                                ;
       F5AC                     FDC_CONTROL_OUT:
0003AC F5AC D3CD            11      OUT (FDC_CONTROL_REG),A ; 
0003AE F5AE 3210FE          13      LD (fdc_control_command),A ; save fdc control command.
0003B1 F5B1 C9              10      RET
                                
                                
                                ;
                                ; Sireal I/O subroutines
                                ;
       F5B2                     SIO_INIT:
                                    ;; Initialize SIO
0003B2 F5B2 DBF9            11      IN  A,(SIOAC)
                                    ;; Reset both Ch.
0003B4 F5B4 3E18             7      LD  A,18H
0003B6 F5B6 D3F9            11      OUT (SIOAC),A
                                
                                    ;; Ch.A WR1
0003B8 F5B8 3E01             7      LD  A,01H
0003BA F5BA D3F9            11      OUT (SIOAC),A
0003BC F5BC AF               4      XOR A
0003BD F5BD D3F9            11      OUT (SIOAC),A
                                
                                    ;; Ch.A WR4
0003BF F5BF 3E04             7      LD  A,04H
0003C1 F5C1 D3F9            11      OUT (SIOAC),A
0003C3 F5C3 3E44             7      LD  A,44H       ; x16 1 N
0003C5 F5C5 D3F9            11      OUT (SIOAC),A
                                
                                    ;; Ch.A WR3
0003C7 F5C7 3E03             7      LD  A,03H
0003C9 F5C9 D3F9            11      OUT (SIOAC),A
0003CB F5CB 3EC1             7      LD  A,0C1H      ; 8bit Receiver enable
0003CD F5CD D3F9            11      OUT (SIOAC),A
                                    
                                    ;; Ch.A WR5
0003CF F5CF 3E05             7      LD  A,05H
0003D1 F5D1 D3F9            11      OUT (SIOAC),A
0003D3 F5D3 3EEA             7      LD  A,0EAH      ; 8bit Transmitter enable
0003D5 F5D5 D3F9            11      OUT (SIOAC),A
0003D7 F5D7 C9              10      RET
                                
       F5D8                     STROUT:
0003D8 F5D8 7E               7      LD  A,(HL)
0003D9 F5D9 A7               4      AND A
0003DA F5DA C8              11      RET Z
0003DB F5DB 4F               4      LD C,A
0003DC F5DC CD25F3          17      CALL    CONOUT
0003DF F5DF 23               6      INC HL
0003E0 F5E0 18F6            12      JR  STROUT
                                
                                ;
                                ; DMA COMMAND CHAIN
                                ;
       F5E2                     DMA_COMMANDS:
0003E2 F5E2 15                      DB 15H
0003E3 F5E3 C3C3C3C3C3C3            DB 0C3H,0C3H,0C3H,0C3H,0C3H,0C3H
0003E9 F5E9 BB01BF                  DB 0BBH,01H,0BFH
0003EC F5EC 6D                      DB 6DH
0003ED F5ED CBFF002C108D            DB 0CBH,0FFH,00H,02CH,010H,08DH
                                    ; DB 029H,0FBH ; host buffer address
0003F3 F5F3 38                      DB hstbuf.@L ; host buffer address 
0003F4 F5F4 FB                      DB hstbuf.@H ; host buffer address
0003F5 F5F5 9A                      DB 9AH
0003F6 F5F6 CF87                    DB 0CFH,87H
       F5F8                     DMA_WRITE_COMMANDS:
0003F8 F5F8 16                      DB 16H
0003F9 F5F9 C3C3C3C3C3C3            DB 0C3H,0C3H,0C3H,0C3H,0C3H,0C3H
0003FF F5FF 83                      DB 83H
000400 F600 79                      DB 79H
                                    ; DB 029H,0FBH ; host buffer address
000401 F601 38                      DB hstbuf.@L ; host buffer address
000402 F602 FB                      DB hstbuf.@H ; host buffer address
000403 F603 00FF                    DB 00H,0FFH ; byte number of transfer
000405 F605 14288D                  DB 14H,28H,8DH
000408 F608 CB00                    DB 0CBH,00H ; FDC data register
00040A F60A 9A                      DB 9AH
00040B F60B CF05                    DB 0CFH,05H
00040D F60D CF87                    DB 0CFH,87H
                                
                                ;
                                ; DMA WBOOT COMMAND CHAIN
                                ;
       F60F                     DMA_WBOOT_COMMANDS:
00040F F60F 15C3C3C3C3C3C3          DB 15H,0C3H,0C3H,0C3H,0C3H,0C3H,0C3H
000416 F616 BB01BF                  DB 0BBH,01H,0BFH
000419 F619 6D                      DB 6DH
00041A F61A CBFF002C108D            DB 0CBH,0FFH,00H,02CH,010H,08DH
000420 F620 00                      DB 00H
000421 F621 DC                  wboot_add:  DB 0DCH ; DC00H is 62K MEMORY MODEL
000422 F622 9A                      DB 9AH
000423 F623 CF87                    DB 0CFH,87H
                                
                                ;
       F625                     OPENMSG:
000425 F625 0D0A534F5244204D        DB CR,LF,"SORD M68(Z80 MODE) CP/M-80 V2.2 62K SYSTEM",CR,LF,00H
            3638285A3830204D    
            4F4445292043502F    
            4D2D38302056322E    
            322036324B205359    
            5354454D0D0A00      
                                ;COPYMSG:
                                ;   DB "Copyright 1979 (C) by Digital Research.",CR,LF,00H
                                ;
                                ;
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; キーボード初期化ルーチン
                                ;
       F654                     KBD_INIT:
                                ;
                                ; キーボードスキャンバッファーを0で埋める。必要ないかも。
                                ;
000454 F654 2100FE          10      LD HL,KEYBOARD_SCAN_BUFFER
000457 F657 011000          10      LD BC,10H
00045A F65A 3E00             7      LD A,0H
00045C F65C 77               7      LD (HL),A
00045D F65D 54               4      LD D,H
00045E F65E 5D               4      LD E,L
00045F F65F 13               6      INC DE
000460 F660 0B               6      DEC BC
000461 F661 78               4      LD A,B
000462 F662 B1               4      OR C
000463 F663 C8              11      RET Z
000464 F664 EDB0                    LDIR
000466 F666 C9              10      RET
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; CRT 初期化ルーチン
                                ;
                                
       F667                     CRT_INIT:
                                
000467 F667 2100F0          10      LD HL,0F000H ; VRAMの左上のアトリビュートアドレス
00046A F66A 010008          10      LD BC,0800H
                                
                                ; カーソル座標を00Hに設定する。
                                ; 注：画面左上がカーソル座標では0000Hになる。VRAMにおけるテキスト画面左上(F800H)ではないことに注意。
00046D F66D 3E0E             7      LD A,0EH ; R14 (cursor H)
00046F F66F D3F0            11      OUT (CRTC_ADD),A
000471 F671 3E00             7      LD A,0H
000473 F673 D3F1            11      OUT (CRTC_VAL),A
000475 F675 3E0F             7      LD A,0FH ; R15 (cursor L)
000477 F677 D3F0            11      OUT (CRTC_ADD),A
000479 F679 3E00             7      LD A,00H
00047B F67B D3F1            11      OUT (CRTC_VAL),A
                                
                                ; カーソルの形状と点滅の設定
00047D F67D 3E0A             7      LD A,0AH ; R10 (cursol start address)
00047F F67F D3F0            11      OUT (CRTC_ADD),A
                                ;   LD A,C0H ; 点滅、豆腐カーソル
000481 F681 3EC7             7      LD A,C7H ; 点滅、アンスコカーソル
                                ;   LD A,0H ; 表示せず。
000483 F683 D3F1            11      OUT (CRTC_VAL),A
000485 F685 3E0B             7      LD A,0BH ; R11 (cursol end address)
000487 F687 D3F0            11      OUT (CRTC_ADD),A
000489 F689 3E0A             7      LD A,0AH
                                ;   LD A,0H ; 表示せず。
00048B F68B D3F1            11      OUT (CRTC_VAL),A
                                
                                ;
                                ;   一度画面全てを消す(スペースで埋める)。
                                ;
00048D F68D 0650             7      LD B,050H
00048F F68F 11FFFF          10      LD DE,0FFFFH
000492 F692 3E20             7      LD A,20H ; 20Hはアスキーコードでスペース
       F694                     CLEAR_ALL_LINE:
000494 F694 D3D2            11      OUT (0D2H),A ; D2Hポートになにか書くと次の命令は別のページ(この場合はVRAMのページ)に行う。
000496 F696 77               7      LD (HL),A ; F000H～FFFFHまで20Hで埋めている。アトリビュートに20H書いても問題ないみたい。
000497 F697 23               6      INC HL
000498 F698 ED52            15      SBC HL,DE
00049A F69A 20F8            12      JR NZ,CLEAR_ALL_LINE
                                
00049C F69C 1100F8          10      LD DE, VRAM_TXT_TOP ; 最初の文字列表示位置(左上隅)
00049F F69F ED53C6FA        20      LD (CURSOR_LOCATE),DE
0004A3 F6A3 ED53C8FA        20      LD (TOP_VIEW),DE
0004A7 F6A7 11D0FF          10      LD DE, 0FFD0H
0004AA F6AA ED53CAFA        20      LD (NEED_DO_SCROLL_POINT),DE
                                
0004AE F6AE C9              10      RET ; 初期化処理終了
                                
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; CRTCコントロールサブルーチン群
                                ;
                                
                                ;
                                ; VRAM_TXT_TOP : VRAMテキストエリアの先頭(F800H)
                                ; CURSOR_LOCATE : 現在のカーソル位置
                                ; CR_NOW_CURSOL_LOCATE : CRコードが入った時のカーソル位置
                                ; TOP_VIEW : 画面左上端のアドレス(スクロールによって動的に変化する)
                                ; CR_BASE_ADDRESS : CR後のカーソル位置
                                ; CR_NEW_ORIGIN : FFFFHの境界を越え、更に画面右端を超えた時にCRアドレス計算の原点になるアドレス
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; １文字表示サブルーチン
                                ; A regに表示するアスキーコードが入っている。
                                ;
                                
       F6AF                     PUTCHAR:
0004AF F6AF A7               4      AND A
0004B0 F6B0 2848            12      JR Z, PUTCHAR_RET
0004B2 F6B2 ED5BC6FA        20      LD DE,(CURSOR_LOCATE)
0004B6 F6B6 FE0D             7      CP CR
0004B8 F6B8 CAFBF6          10      JP Z, DO_CR ; CRの処理
0004BB F6BB FE0A             7      CP LF
0004BD F6BD CAA0F7          10      JP Z, DO_LF ; LFの処理
0004C0 F6C0 FE08             7      CP BS
0004C2 F6C2 CAC4F7          10      JP Z, DO_BS ; BSの処理
       F6C5                     DO_NORMAL:
0004C5 F6C5 D3D2            11      OUT (0D2H),A ; access to RAM page 1
0004C7 F6C7 12               7      LD (DE),A ; put character
                                ;
                                ; 越境判定。FFFFHの次はF800Hになる
                                ;
0004C8 F6C8 F5              11      PUSH AF
0004C9 F6C9 7A               4      LD A,D
0004CA F6CA FEFF             7      CP 0FFH
0004CC F6CC 2008            12      JR NZ,CURSOR_BOUNDARY_END
0004CE F6CE 7B               4      LD A,E
0004CF F6CF FEFF             7      CP 0FFH
0004D1 F6D1 2003            12      JR NZ,CURSOR_BOUNDARY_END
0004D3 F6D3 11FFF7          10      LD DE, VRAM_TXT_TOP-1 ; 現在のカーソル位置 = F800H - 1 
       F6D6                     CURSOR_BOUNDARY_END:
0004D6 F6D6 F1              10      POP AF
0004D7 F6D7 13               6      INC DE
       F6D8                     DO_CR_LF_BS_RETURN: ; CR,LF,BSの処理で戻ってくる
0004D8 F6D8 E5              11      PUSH HL
0004D9 F6D9 F5              11      PUSH AF
0004DA F6DA D5              11      PUSH DE
0004DB F6DB CDCDF7          17      CALL DO_SCROLL ; 1行スクロール処理
0004DE F6DE D1              10      POP DE
0004DF F6DF F1              10      POP AF
0004E0 F6E0 E1              10      POP HL
0004E1 F6E1 ED53C6FA        20      LD (CURSOR_LOCATE),DE ; 現在のカーソル位置を更新。
                                ;
                                ; カーソルをCURSOL_LOCATE=DEの位置に表示する(HD46505Sの機能)
                                ;
0004E5 F6E5 F5              11      PUSH AF
0004E6 F6E6 D5              11      PUSH DE
0004E7 F6E7 E5              11      PUSH HL
0004E8 F6E8 EB               4      EX DE,HL
0004E9 F6E9 3E0E             7      LD A,0EH ; R14 (cursor H)
0004EB F6EB D3F0            11      OUT (CRTC_ADD),A
0004ED F6ED 7C               4      LD A,H
0004EE F6EE D3F1            11      OUT (CRTC_VAL),A
0004F0 F6F0 3E0F             7      LD A,0FH ; R15 (cursor L)
0004F2 F6F2 D3F0            11      OUT (CRTC_ADD),A
0004F4 F6F4 7D               4      LD A,L
0004F5 F6F5 D3F1            11      OUT (CRTC_VAL),A
0004F7 F6F7 E1              10      POP HL
0004F8 F6F8 D1              10      POP DE
0004F9 F6F9 F1              10      POP AF
                                ;
       F6FA                     PUTCHAR_RET:
0004FA F6FA C9              10      RET
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; CR処理ルーチン(スクロール処理対応版)
                                ;
                                
       F6FB                     DO_CR:
0004FB F6FB E5              11      PUSH HL
0004FC F6FC C5              11      PUSH BC
0004FD F6FD AF               4      XOR A ; A=0にする
0004FE F6FE ED53D0FA        20      LD (CR_NOW_CURSOL_LOCATE),DE ; 現在のカーソル位置保存
000502 F702 2AC8FA          16      LD HL,(TOP_VIEW) ; 左上端をロード
000505 F705 EB               4      EX DE,HL
000506 F706 ED52            15      SBC HL,DE ; 左上端アドレス - 現在のカーソル位置
000508 F708 3062            12      JR NC,CONTINUE_CR ; オーバーフローしていないなら単純処理
                                ;
                                ;   TOP_VIEWがCR_NOW_CURSOL_LOCATEよりも大きいとき。
                                ;   この状況は、スクロールされた時に発生する。
                                ;   つまり、殆どの場合、この処理が実行される。
                                ;
00050A F70A 2AC8FA          16      LD HL,(TOP_VIEW)
00050D F70D ED5BD0FA        20      LD DE,(CR_NOW_CURSOL_LOCATE) ; CRコードが入った時のカーソル位置
000511 F711 015000          10      LD BC,WIDTH_SCREEN ;  50H =  画面の桁数(80d)
000514 F714 22CCFA          16      LD (CR_BASE_ADDRESS),HL ; 初期値は左上端アドレス
       F717                     CR_SCAN_0:
000517 F717 2ACCFA          16      LD HL,(CR_BASE_ADDRESS)
00051A F71A 22CEFA          16      LD (CR_BASE_ADDRESS_PRE),HL
00051D F71D 09              11      ADD HL,BC ; 50H(80d)づつ足していく
00051E F71E 22CCFA          16      LD (CR_BASE_ADDRESS),HL
000521 F721 D217F7          10      JP NC,CR_SCAN_0     ; 越境をチェックしていて、オーバーフローまでループする。
                                                        ; オーバーフローしたらジャンプ
000524 F724 2ACEFA          16      LD HL,(CR_BASE_ADDRESS_PRE) ; ループを抜けたときHLはオーバーフロー後の値になっていいる。
                                                                ; 足し算前の値に戻す
                                    ; FFFFHを超えた値がいくつかを調べる。
                                    ; FFFFHまでの値と合わせて、それが1行の桁数50H(80d)を
                                    ; 超えたなら、CR後の現在カーソル位置は
                                    ; その新しい行の先頭アドレスにならなくてはならない。
                                    ; 
000527 F727 11FFFF          10      LD DE,0FFFFH ; 境界値
00052A F72A EB               4      EX DE,HL
00052B F72B ED52            15      SBC HL,DE ; FFFFH - CR_BASE_ADDRESS_PRE = A
                                              ; オーバーフローする一つ前の値でFFFFHを引く
00052D F72D 115000          10      LD DE,WIDTH_SCREEN ; 50H(80d)
000530 F730 EB               4      EX DE,HL
000531 F731 ED52            15      SBC HL,DE ; 50H(80d) - A = X ; Xは境界を越えた数
000533 F733 1100F8          10      LD DE,VRAM_TXT_TOP ; VRAM_TXT_TOP = F800H
000536 F736 19              11      ADD HL,DE ; F800H + X ; この値が境界を含む行の右端のアドレス
000537 F737 2B               6      DEC HL ; -2する
000538 F738 2B               6      DEC HL
000539 F739 22D2FA          16      LD (CR_NEW_ORIGIN),HL ; 新しいCR評価位置になる
00053C F73C 22CCFA          16      LD (CR_BASE_ADDRESS),HL
00053F F73F ED5BD0FA        20      LD DE,(CR_NOW_CURSOL_LOCATE) ; CR命令を受けた時のカーソル位置
                                
                                    ;
                                    ; 例えば現在カーソル位置がF819Hで新しいCR評価位置がF820Hのときに、
                                    ; CR_2_NEW_SCAN_0のループを通ると+50Hされてしまうので、バイパスする処理。
000543 F743 ED52            15      SBC HL,DE
000545 F745 F29AF7          10      JP P,CR_BOUNDARY_RETURN ; 正であれば、ジャンプ
                                    ;
                                    ;
000548 F748 2AD2FA          16      LD HL,(CR_NEW_ORIGIN) ; 負であれば、そのまま処理を進める。
00054B F74B 015000          10      LD BC,WIDTH_SCREEN ;  50H(80d)
       F74E                     CR_NEW_SCAN_0:
00054E F74E 2ACCFA          16      LD HL,(CR_BASE_ADDRESS)
000551 F751 22CEFA          16      LD (CR_BASE_ADDRESS_PRE),HL ; HL=CR_NEW_ORIGIN
000554 F754 09              11      ADD HL,BC ; CR_NEW_ORIGIN + 50H +...
000555 F755 22CCFA          16      LD (CR_BASE_ADDRESS),HL
000558 F758 ED52            15      SBC HL,DE ; (CR_NEW_ORIGIN + 50H +...) > CR_NOW_CURSOL_LOCATE ?
00055A F75A FA4EF7          10      JP M, CR_NEW_SCAN_0 ; DEの方が大きければループ
00055D F75D CA4EF7          10      JP Z, CR_NEW_SCAN_0 ; 完全に一致したときも1回ループを回す
000560 F760 2ACEFA          16      LD HL,(CR_BASE_ADDRESS_PRE) ; HL>DE。50Hを足す一つ前の値をHLに入れる。
000563 F763 22CCFA          16      LD (CR_BASE_ADDRESS),HL
000566 F766 ED5BCCFA        20      LD DE,(CR_BASE_ADDRESS) ; CR後のアドレスをDEに入れる。
00056A F76A 1829            12      JR CR_END
                                ;
                                ;   TOP_VIEWがCR_NOW_CURSOL_LOCATEよりも小さいとき
                                ;
       F76C                     CONTINUE_CR:
00056C F76C 2AC8FA          16      LD HL,(TOP_VIEW)
00056F F76F ED5BD0FA        20      LD DE,(CR_NOW_CURSOL_LOCATE)
000573 F773 015000          10      LD BC,WIDTH_SCREEN ; 50H(80d) 
000576 F776 22CCFA          16      LD (CR_BASE_ADDRESS),HL
       F779                     CR_SCAN_1:
000579 F779 2ACCFA          16      LD HL,(CR_BASE_ADDRESS)
00057C F77C 22CEFA          16      LD (CR_BASE_ADDRESS_PRE),HL
00057F F77F 09              11      ADD HL,BC
000580 F780 22CCFA          16      LD (CR_BASE_ADDRESS),HL
000583 F783 ED52            15      SBC HL,DE   ; HLが現在のカーソル位置を超えるかチェック
000585 F785 FA79F7          10      JP M,CR_SCAN_1
000588 F788 CA79F7          10      JP Z,CR_SCAN_1 ; 完全に一致したときも1回ループを回す。
00058B F78B 2ACEFA          16      LD HL,(CR_BASE_ADDRESS_PRE)
00058E F78E 22CCFA          16      LD (CR_BASE_ADDRESS),HL
000591 F791 ED5BCCFA        20      LD DE,(CR_BASE_ADDRESS)
       F795                     CR_END:
000595 F795 C1              10      POP BC
000596 F796 E1              10      POP HL
000597 F797 C3D8F6          10      JP DO_CR_LF_BS_RETURN; CR,LF,BSの処理の終了
                                
       F79A                     CR_BOUNDARY_RETURN:
00059A F79A ED5BCEFA        20      LD DE,(CR_BASE_ADDRESS_PRE)
00059E F79E 18F5            12      JR CR_END
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; LINE_FEED 処理(スクロール処理対応版)
                                ;
                                
       F7A0                     DO_LF:
0005A0 F7A0 E5              11      PUSH HL
0005A1 F7A1 C5              11      PUSH BC
0005A2 F7A2 EB               4      EX DE,HL ; HL <-> DE DE=現在のカーソル位置
0005A3 F7A3 015000          10      LD BC,WIDTH_SCREEN ; 50H(80d)
0005A6 F7A6 09              11      ADD HL,BC ; HL = DE + 50H
0005A7 F7A7 3015            12      JR NC,CONTINUE_LF
                                ;
                                ;   BEYOND FFFFH BOUNDARY
                                ;
0005A9 F7A9 2AC6FA          16      LD HL,(CURSOR_LOCATE)
0005AC F7AC 11FFFF          10      LD DE,0FFFFH
0005AF F7AF EB               4      EX DE,HL
0005B0 F7B0 ED52            15      SBC HL,DE ; FFFFH - CURSOR_LOCATE = A
0005B2 F7B2 115000          10      LD DE,50H
0005B5 F7B5 EB               4      EX DE,HL
0005B6 F7B6 ED52            15      SBC HL,DE ; 50H - A = X
                                ;
0005B8 F7B8 2B               6      DEC HL ; この引き算二回の処理がないと正しい左端のアドレスが出ない。
0005B9 F7B9 2B               6      DEC HL ; これはCP/Mでは常にプロンプト(a>)の2文字が出ているため。
                                ;
0005BA F7BA 1100F8          10      LD DE,VRAM_TXT_TOP
0005BD F7BD 19              11      ADD HL,DE
       F7BE                     CONTINUE_LF:
0005BE F7BE EB               4      EX DE,HL ; DE <-> HL
0005BF F7BF C1              10      POP BC
0005C0 F7C0 E1              10      POP HL
0005C1 F7C1 C3D8F6          10      JP DO_CR_LF_BS_RETURN
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; BACK SPACE 処理
                                ;
       F7C4                     DO_BS:
0005C4 F7C4 3E20             7      LD A, 20H ; 20H -> Space ASCII CODE
0005C6 F7C6 1B               6      DEC DE
0005C7 F7C7 D3D2            11      OUT (0D2H),A ; access to RAM page 1
0005C9 F7C9 12               7      LD (DE),A ; 20H(スペース)を表示させる。
0005CA F7CA C3D8F6          10      JP DO_CR_LF_BS_RETURN ; BSの為の復帰点に戻る。
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; スクロール処理
                                ; SORD M23のCRTCであるHD4650SPはスクロール機能がある。
                                ; 具体的には表示したい画面左上端のアドレスを、R12、R13に上位、下位アドレスとして入れることで実行される。
                                ; SORD M23のVRAMのテキストエリアはF800H～FFFFHであるが、画面に表示される文字は80桁×25行の2000(7D0H)文字である。
                                ; よって、余りが生じるため、スクロール処理は殆どがこの余りの処理に費やされる。
                                ;
                                
       F7CD                     DO_SCROLL:
0005CD F7CD ED53C6FA        20      LD (CURSOR_LOCATE),DE ; 現在のカーソル位置を更新
0005D1 F7D1 2AC8FA          16      LD HL,(TOP_VIEW) ; 左上端アドレス
0005D4 F7D4 11D007          10      LD DE,7D0H ; 全画面文字数
0005D7 F7D7 19              11      ADD HL,DE ; TOP_VIEW + 7D0H ; 
0005D8 F7D8 3802            12      JR C,SCROLL_POINT_BEYOND_FFFF ; 境界値をまたいでいる、オーバーフローしたらジャンプ
0005DA F7DA 1813            12      JR SCROLL_POINT ; スクロールすべきカーソル位置の更新へ
       F7DC                     SCROLL_POINT_BEYOND_FFFF:
0005DC F7DC 2AC8FA          16      LD HL,(TOP_VIEW)
0005DF F7DF 11FFFF          10      LD DE,0FFFFH
0005E2 F7E2 EB               4      EX DE,HL
0005E3 F7E3 ED52            15      SBC HL,DE ; FFFFH - TOP_VIEW = A
0005E5 F7E5 11CE07          10      LD DE,7CEH ; 7D0H - 2H
0005E8 F7E8 EB               4      EX DE,HL
0005E9 F7E9 ED52            15      SBC HL,DE ; 7CEH - A
0005EB F7EB 1100F8          10      LD DE,VRAM_TXT_TOP
0005EE F7EE 19              11      ADD HL,DE
                                    ;
       F7EF                     SCROLL_POINT:
                                    ; update need_do_scroll_point
0005EF F7EF 22CAFA          16      LD (NEED_DO_SCROLL_POINT),HL
0005F2 F7F2 ED5BC6FA        20      LD DE,(CURSOR_LOCATE)
0005F6 F7F6 7A               4      LD A,D ; need_do_scroll_point == CURSOL_LOCATE?
0005F7 F7F7 BC               4      CP H
0005F8 F7F8 C0              11      RET NZ
0005F9 F7F9 7B               4      LD A,E
0005FA F7FA BD               4      CP L
0005FB F7FB C0              11      RET NZ
                                ;
                                ; TOP_VIEWの更新
                                ;
                                
                                ; スクロールから外れた行をスペースで埋める。
0005FC F7FC 2AC8FA          16      LD HL,(TOP_VIEW) ; スクロール直前の左上端アドレス
0005FF F7FF C5              11      PUSH BC
000600 F800 D5              11      PUSH DE
000601 F801 F5              11      PUSH AF
000602 F802 064F             7      LD B,04FH ; 4FH=79
000604 F804 11FFFF          10      LD DE,0FFFFH
000607 F807 3E20             7      LD A,20H ; 20H is Space
       F809                     CLEAR_1_LINE:
000609 F809 D3D2            11      OUT (0D2H),A
00060B F80B 77               7      LD (HL),A ; スペースで埋める
00060C F80C E5              11      PUSH HL ; HL < FFFFHのとき、下の引き算はオーバーフローするが、
                                            ; HL=F800Hの時に実行すると、HL=F801となり、
                                            ; その後INC HLでF802Hになるため、スペースによる穴埋めがF801Hのみ実行されないことになる。
                                            ; なので、一度、HLを退避して、引き算してFFFFHでないか判定したのち、POPして戻している。
                                            ; このコードは遅いが、現状、これを採用する。20221229
00060D F80D ED52            15      SBC HL,DE ; HL - FFFFH = HL
00060F F80F E1              10      POP HL
000610 F810 2805            12      JR Z, CLEAR_BEYOND_BOUNDARY ; HL = FFFFHのときは境界を越えた
000612 F812 23               6      INC HL
000613 F813 10F4            13      DJNZ CLEAR_1_LINE
000615 F815 1809            12      JR CLEAR_1_LINE_END
                                    ; 越境時の処理
       F817                     CLEAR_BEYOND_BOUNDARY:
000617 F817 2100F8          10      LD HL,VRAM_TXT_TOP ; HLをVRAMの先頭(F800H)にセット
       F81A                     CLEAR_1_LINE_BOUNDARY: ; B回ループする
00061A F81A D3D2            11      OUT (0D2H),A
00061C F81C 77               7      LD (HL),A
00061D F81D 23               6      INC HL
00061E F81E 10FA            13      DJNZ CLEAR_1_LINE_BOUNDARY
       F820                     CLEAR_1_LINE_END:
000620 F820 F1              10      POP AF
000621 F821 D1              10      POP DE
000622 F822 C1              10      POP BC
                                ;
                                ;
000623 F823 2AC8FA          16      LD HL,(TOP_VIEW)
000626 F826 115000          10      LD DE,50H
000629 F829 19              11      ADD HL,DE
00062A F82A 3015            12      JR NC,UPDATE_TOP_VIEW
                                ;
                                ;   BEYOND FFFFH BOUNDARY
                                ;
00062C F82C 11FFFF          10      LD DE,0FFFFH
00062F F82F 2AC8FA          16      LD HL,(TOP_VIEW)
000632 F832 EB               4      EX DE,HL
000633 F833 ED52            15      SBC HL,DE ; FFFFH - TOP_VIEW = A
000635 F835 115000          10      LD DE,50H
000638 F838 EB               4      EX DE,HL
000639 F839 ED52            15      SBC HL,DE ; 50H - A = X
00063B F83B 1100F8          10      LD DE,0F800H
00063E F83E 19              11      ADD HL,DE ; F800H + X = TOP_VIEW
                                ;
00063F F83F 2B               6      DEC HL ; この引き算二回の処理がないと正しい左端のアドレスが出ない。
000640 F840 2B               6      DEC HL ; これはCP/Mでは常にプロンプト(a>)の2文字が出ているため。
                                ;
       F841                     UPDATE_TOP_VIEW:
000641 F841 22C8FA          16      LD (TOP_VIEW),HL
                                    ;
                                    ; 1行スクロール
                                    ;
000644 F844 F5              11      PUSH AF
000645 F845 3E0C             7      LD A,0CH ; START ADDRESS HIGH
000647 F847 D3F0            11      OUT (CRTC_ADD),A
000649 F849 7C               4      LD A,H ; スクロールしたときに左隅になるVRAMの上位アドレス
00064A F84A D3F1            11      OUT (CRTC_VAL),A
00064C F84C 3E0D             7      LD A,0DH ; START ADDRESS LOW
00064E F84E D3F0            11      OUT (CRTC_ADD),A
000650 F850 7D               4      LD A,L ; スクロールしたときに左隅になるVRAMの下位アドレス
000651 F851 D3F1            11      OUT (CRTC_VAL),A
000653 F853 F1              10      POP AF
       F854                     SCROLL_END:
000654 F854 C9              10      RET
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; キースキャン サブルーチン
                                ;
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                
       F855                     KEY_SCAN_LAP:
000655 F855 E5              11      PUSH HL
000656 F856 C5              11      PUSH BC
       F857                     KEY_SCAN_LAP_LOOP:
000657 F857 2100FE          10      LD HL,PORT_INDEX
00065A F85A 01DF0F          10      LD BC,0FDFH
00065D F85D CD66F8          17      CALL KEY_SCAN
000660 F860 A7               4      AND A
000661 F861 28F4            12      JR Z,KEY_SCAN_LAP_LOOP
000663 F863 C1              10      POP BC
000664 F864 E1              10      POP HL
000665 F865 C9              10      RET
                                
       F866                     KEY_SCAN:
000666 F866 0C               4      INC C
000667 F867 EDA2            16      INI ; INIでキーボードポートE0~EFをスキャンする。
000669 F869 20FB            12      JR NZ,KEY_SCAN ; Cをインクリメントしていくと、1->2->3...e->f->0となって、スキャン終了となる。
00066B F86B 2100FE          10      LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
00066E F86E 01DF0F          10      LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
       F871                     SCAN_LOOP:
000671 F871 0C               4      INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
000672 F872 ED78            12      IN A,(C)
000674 F874 A6               7      AND (HL) ; INIでスキャンした結果と照合。
000675 F875 77               7      LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
000676 F876 23               6      INC HL ; メモリアドレスをインクリメント。
000677 F877 10F8            13      DJNZ SCAN_LOOP ; 16回繰り返す
                                
000679 F879 2100FE          10      LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
00067C F87C 1600             7      LD D,0H ; インデックスを0にする。
00067E F87E 1801            12      JR KEY_LOOP_1
       F880                     SCAN_LOOP_RETURN:
000680 F880 C9              10      RET
                                
       F881                     KEY_LOOP_1:
000681 F881 7E               7      LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
000682 F882 A7               4      AND A ; 0でないか、つまり、空の値でないかチェック。
000683 F883 200B            12      JR NZ, KEY_LOOP_2 ; 空でない場合、つまり、何かが押されているならジャンプ
000685 F885 14               4      INC D ; インデックスをインクリメント
000686 F886 23               6      INC HL ; ポインタをインクリメント
000687 F887 7A               4      LD A,D
000688 F888 FE0F             7      CP 0FH ; 16バイトチェックしたか？
00068A F88A 3E00             7      LD A,0H ; なにもキーが押されなかったときはAレジスタを0にする。
00068C F88C 28F2            12      JR Z,SCAN_LOOP_RETURN ; 終了
00068E F88E 18F1            12      JR KEY_LOOP_1 
                                
                                ;
                                ; 何かが押されている時に実行される。
                                ;
                                
       F890                     KEY_LOOP_2: 
000690 F890 FE04             7      CP 04H ; キーボード1段目のキーが押された。(1,2,3,4,5,6,7,8,9,0,-,=,BS)
000692 F892 C29AF8          10      JP NZ,CHECK_ROW2
000695 F895 1600             7      LD D,0
000697 F897 C3E2F8          10      JP PROCESS_KEY
       F89A                     CHECK_ROW2:
00069A F89A FE08             7      CP 08H ; キーボード2段目のキーが押された。(q,w,e,r,t,y,u,i,o,p,CR)
00069C F89C C2A4F8          10      JP NZ,CHECK_ROW3
00069F F89F 1601             7      LD D,1
0006A1 F8A1 C3E2F8          10      JP PROCESS_KEY
       F8A4                     CHECK_ROW3:
0006A4 F8A4 FE10             7      CP 10H ; キーボード3段目のキーが押された。(control,a,s,d,f,g,h,j,k,l)
0006A6 F8A6 C2B6F8          10      JP NZ,CHECK_ROW4
0006A9 F8A9 7D               4      LD A,L
0006AA F8AA E60F             7      AND 0FH
0006AC F8AC FE00             7      CP 00H
0006AE F8AE CAEDF8          10      JP Z,CODE_CONTROL  ; コントロールキー特殊処理
0006B1 F8B1 1602             7      LD D,2
0006B3 F8B3 C3E2F8          10      JP PROCESS_KEY
       F8B6                     CHECK_ROW4:
0006B6 F8B6 FE20             7      CP 20H ; キーボード4段目のキーが押された。(shift,z,x,c,v,b,n,m,shift)
0006B8 F8B8 C2C8F8          10      JP NZ,CHECK_ROW5
0006BB F8BB 7D               4      LD A,L
0006BC F8BC E60F             7      AND 0FH
0006BE F8BE FE00             7      CP 00H
0006C0 F8C0 CAF3F8          10      JP Z,CODE_SHIFT   ; シフトキー特殊処理
0006C3 F8C3 1603             7      LD D,3
0006C5 F8C5 C3E2F8          10      JP PROCESS_KEY
       F8C8                     CHECK_ROW5:
0006C8 F8C8 CAF9F8          10      JP Z,KEY_LOOP_END  ; 元の CODE_40 ラベルへのジャンプを KEY_LOOP_END に変更  CP 40H
                                
                                ;
                                ; 共通のキーマップ参照ルーチン
                                ; 入力: D = キーボード段数（0-3）
                                ;       L = キー位置
                                ; 出力: A = マップされたキーコード
                                ;
       F8CB                     GET_KEYMAP:
0006CB F8CB E5              11      PUSH HL
0006CC F8CC C5              11      PUSH BC
0006CD F8CD 7D               4      LD A,L
0006CE F8CE E60F             7      AND 0FH        ; 下位4ビットのみ使用
0006D0 F8D0 47               4      LD B,A         ; キー位置
0006D1 F8D1 7A               4      LD A,D         ; キーボード段数
0006D2 F8D2 87               4      ADD A,A        ; ×16のために4回シフト
0006D3 F8D3 87               4      ADD A,A
0006D4 F8D4 87               4      ADD A,A
0006D5 F8D5 87               4      ADD A,A
0006D6 F8D6 80               4      ADD A,B        ; キー位置を加算
0006D7 F8D7 21E3FA          10      LD HL,KEY_MAP
0006DA F8DA 0600             7      LD B,0
0006DC F8DC 4F               4      LD C,A
0006DD F8DD 09              11      ADD HL,BC      ; HL = KEY_MAP + オフセット
0006DE F8DE 7E               7      LD A,(HL)      ; マップされたコードを取得
0006DF F8DF C1              10      POP BC
0006E0 F8E0 E1              10      POP HL
0006E1 F8E1 C9              10      RET
                                
                                ;
                                ; 共通のキー処理ルーチン
                                ; 入力: D = キーボード段数（0-3）
                                ;
       F8E2                     PROCESS_KEY:
0006E2 F8E2 CDCBF8          17      CALL GET_KEYMAP
0006E5 F8E5 F5              11      PUSH AF
0006E6 F8E6 CDFEF8          17      CALL KEY_BREAK_WAIT
0006E9 F8E9 F1              10      POP AF
0006EA F8EA C380F8          10      JP SCAN_LOOP_RETURN
                                
                                ;
                                ; 特殊キー(CONTROL,SHIFT)の処理
                                ;
                                
       F8ED                     CODE_CONTROL:
0006ED F8ED CD29FA          17      CALL CONTROL_KEY_NEXT_GET
0006F0 F8F0 C380F8          10      JP SCAN_LOOP_RETURN
                                
       F8F3                     CODE_SHIFT:
0006F3 F8F3 CD21F9          17      CALL SHIFT_KEY_NEXT_GET
0006F6 F8F6 C380F8          10      JP SCAN_LOOP_RETURN
                                
       F8F9                     KEY_LOOP_END:
0006F9 F8F9 3E1B             7      LD A, 1BH ; どれにも該当しないキーを押したときは、エスケープキーを押したことにする。
0006FB F8FB C380F8          10      JP SCAN_LOOP_RETURN
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; キーの押下が解放されるまで待つサブルーチン
                                ;
                                
       F8FE                     KEY_BREAK_WAIT:
0006FE F8FE 2100FE          10      LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
000701 F901 01DF0F          10      LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
       F904                     BREAK_SCAN_LOOP:
000704 F904 0C               4      INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
000705 F905 ED78            12      IN A,(C)
000707 F907 A6               7      AND (HL) ; INIでスキャンした結果と照合。
000708 F908 77               7      LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
000709 F909 23               6      INC HL ; メモリアドレスをインクリメント。
00070A F90A 10F8            13      DJNZ BREAK_SCAN_LOOP ; 16回繰り返す
                                
00070C F90C 2100FE          10      LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
00070F F90F 1600             7      LD D,0H ; インデックスを0にする。
000711 F911 060F             7      LD B,0FH
000713 F913 1E00             7      LD E,0H
                                
       F915                     BREAK_KEY_LOOP:
000715 F915 7E               7      LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
000716 F916 83               4      ADD A, E 
000717 F917 5F               4      LD E, A ; Eにキースキャンの値を積算する。
000718 F918 14               4      INC D ; インデックスをインクリメント
000719 F919 23               6      INC HL ; ポインタをインクリメント
00071A F91A 10F9            13      DJNZ BREAK_KEY_LOOP
00071C F91C 7B               4      LD A,E ; キースキャンの値の総和をAに戻す。
00071D F91D A7               4      AND A ; ゼロかどうか判定の為、自分自身でANDをとる。
00071E F91E C8              11      RET Z ; 全てのキーボードポートが0の時にリターンする。
00071F F91F 18DD            12      JR KEY_BREAK_WAIT
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; SHIFTキーと同時に押されたキーをゲットするサブルーチン
                                ;
                                
       F921                     SHIFT_KEY_NEXT_GET:
000721 F921 2100FE          10      LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
000724 F924 01DF0F          10      LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
       F927                     SHIFT_SCAN_LOOP:
000727 F927 0C               4      INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
000728 F928 ED78            12      IN A,(C)
00072A F92A 77               7      LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
00072B F92B 23               6      INC HL ; メモリアドレスをインクリメント。
00072C F92C 10F9            13      DJNZ SHIFT_SCAN_LOOP ; 16回繰り返す
                                
00072E F92E 2100FE          10      LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
000731 F931 1600             7      LD D,0H ; インデックスを 1 にする。
000733 F933 060F             7      LD B,0FH ; B=FH=16
000735 F935 1E00             7      LD E,0H
                                
                                ;
                                ; SHIFTキーを離すか、他のキーが押されるまではループする。
                                ;
                                
       F937                     SHIFT_NEXT_KEY_LOOP:
000737 F937 3A00FE          13      LD A, (PORT_INDEX)
00073A F93A A7               4      AND A
00073B F93B 3E1B             7      LD A,1BH
00073D F93D C8              11      RET Z ; [EE00]=0、SHIFTキー押されてないならリターンする。
00073E F93E 23               6      INC HL
00073F F93F 14               4      INC D
000740 F940 7E               7      LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
000741 F941 A7               4      AND A
000742 F942 2007            12      JR NZ, SHIFT_KEY_LOOP ; キーが押下されている時はジャンプする。
000744 F944 7A               4      LD A,D
000745 F945 FE0F             7      CP 0FH ; D=A=16バイトチェックしたか？
000747 F947 28D8            12      JR Z, SHIFT_KEY_NEXT_GET ; 16バイト読み込んで、SHIFTキー以外何も押されていないなら、一番最初のループに戻る
000749 F949 18EC            12      JR SHIFT_NEXT_KEY_LOOP ; 16バイト読んでないなら、次のメモリを読む。
                                    
       F94B                     SHIFT_KEY_LOOP:
00074B F94B FE04             7      CP 04H
00074D F94D CA5FF9          10      JP Z, CODE_04_SHIFT
000750 F950 FE08             7      CP 08H
000752 F952 CA8FF9          10      JP Z, CODE_08_SHIFT
000755 F955 FE10             7      CP 10H
000757 F957 CA9CF9          10      JP Z, CODE_10_SHIFT
00075A F95A FE20             7      CP 20H
00075C F95C CAAEF9          10      JP Z, CODE_20_SHIFT
                                
                                
       F95F                     CODE_04_SHIFT:
00075F F95F 7D               4      LD A,L
000760 F960 E60F             7      AND 0FH
                                
000762 F962 FE01             7      CP 01H
000764 F964 CAC3F9          10      JP Z, CODE_1_SHIFT
000767 F967 FE02             7      CP 02H
000769 F969 CAC9F9          10      JP Z, CODE_2_SHIFT
00076C F96C FE03             7      CP 03H
00076E F96E CACFF9          10      JP Z, CODE_3_SHIFT
000771 F971 FE04             7      CP 04H
000773 F973 CAD5F9          10      JP Z, CODE_4_SHIFT
000776 F976 FE05             7      CP 05H
000778 F978 CADBF9          10      JP Z, CODE_5_SHIFT
00077B F97B FE06             7      CP 06H
00077D F97D CAE1F9          10      JP Z, CODE_6_SHIFT
000780 F980 FE07             7      CP 07H
000782 F982 CAE7F9          10      JP Z, CODE_7_SHIFT
000785 F985 FE08             7      CP 08H
000787 F987 CAEDF9          10      JP Z, CODE_8_SHIFT
00078A F98A FE09             7      CP 09H
00078C F98C CAF3F9          10      JP Z, CODE_9_SHIFT
                                
       F98F                     CODE_08_SHIFT:
00078F F98F 7D               4      LD A,L
000790 F990 E60F             7      AND 0FH
                                
000792 F992 FE0B             7      CP 0BH
000794 F994 CAF9F9          10      JP Z, CODE_AT_MARK_SHIFT
000797 F997 FE0C             7      CP 0CH
000799 F999 CAFFF9          10      JP Z, CODE_L_SQ_PAR_SHIFT
                                
       F99C                     CODE_10_SHIFT:
00079C F99C 7D               4      LD A,L
00079D F99D E60F             7      AND 0FH
                                
00079F F99F FE0A             7      CP 0AH
0007A1 F9A1 CA05FA          10      JP Z, CODE_SEMI_COLON_SHIFT
0007A4 F9A4 FE0B             7      CP 0BH
0007A6 F9A6 CA0BFA          10      JP Z, CODE_COLON_SHIFT
0007A9 F9A9 FE0C             7      CP 0CH
0007AB F9AB CA11FA          10      JP Z, CODE_R_SQ_PAR_SHIFT
                                
       F9AE                     CODE_20_SHIFT:
                                
0007AE F9AE 7D               4      LD A,L
0007AF F9AF E60F             7      AND 0FH
                                
0007B1 F9B1 FE09             7      CP 09H
0007B3 F9B3 CA17FA          10      JP Z, CODE_COMMA_SHIFT
0007B6 F9B6 FE0A             7      CP 0AH
0007B8 F9B8 CA1DFA          10      JP Z, CODE_PERIOD_SHIFT
0007BB F9BB FE0B             7      CP 0BH
0007BD F9BD CA23FA          10      JP Z, CODE_SLASH_SHIFT
                                
0007C0 F9C0 3E00             7      LD A,0H
0007C2 F9C2 C9              10      RET
                                
       F9C3                     CODE_1_SHIFT:
0007C3 F9C3 CDFEF8          17      CALL KEY_BREAK_WAIT
0007C6 F9C6 3E21             7      LD A, '!'
0007C8 F9C8 C9              10      RET
       F9C9                     CODE_2_SHIFT:
0007C9 F9C9 CDFEF8          17      CALL KEY_BREAK_WAIT
0007CC F9CC 3E22             7      LD A, 22H
0007CE F9CE C9              10      RET
       F9CF                     CODE_3_SHIFT:
0007CF F9CF CDFEF8          17      CALL KEY_BREAK_WAIT
0007D2 F9D2 3E23             7      LD A, '#'
0007D4 F9D4 C9              10      RET
       F9D5                     CODE_4_SHIFT:
0007D5 F9D5 CDFEF8          17      CALL KEY_BREAK_WAIT
0007D8 F9D8 3E24             7      LD A, '$'
0007DA F9DA C9              10      RET
       F9DB                     CODE_5_SHIFT:
0007DB F9DB CDFEF8          17      CALL KEY_BREAK_WAIT
0007DE F9DE 3E25             7      LD A, '%'
0007E0 F9E0 C9              10      RET
       F9E1                     CODE_6_SHIFT:
0007E1 F9E1 CDFEF8          17      CALL KEY_BREAK_WAIT
0007E4 F9E4 3E26             7      LD A, '&'
0007E6 F9E6 C9              10      RET
       F9E7                     CODE_7_SHIFT:
0007E7 F9E7 CDFEF8          17      CALL KEY_BREAK_WAIT
0007EA F9EA 3E27             7      LD A, 27H ; 27Hは "'" 。シングルクォーテーション。
0007EC F9EC C9              10      RET
       F9ED                     CODE_8_SHIFT:
0007ED F9ED CDFEF8          17      CALL KEY_BREAK_WAIT
0007F0 F9F0 3E28             7      LD A, '('
0007F2 F9F2 C9              10      RET
       F9F3                     CODE_9_SHIFT:
0007F3 F9F3 CDFEF8          17      CALL KEY_BREAK_WAIT
0007F6 F9F6 3E29             7      LD A, ')'
0007F8 F9F8 C9              10      RET
                                
       F9F9                     CODE_AT_MARK_SHIFT:
0007F9 F9F9 CDFEF8          17      CALL KEY_BREAK_WAIT
0007FC F9FC 3E60             7      LD A, '`'
0007FE F9FE C9              10      RET
       F9FF                     CODE_L_SQ_PAR_SHIFT:
0007FF F9FF CDFEF8          17      CALL KEY_BREAK_WAIT
000802 FA02 3E7B             7      LD A, '{'
000804 FA04 C9              10      RET
       FA05                     CODE_SEMI_COLON_SHIFT:
000805 FA05 CDFEF8          17      CALL KEY_BREAK_WAIT
000808 FA08 3E2B             7      LD A, '+'
00080A FA0A C9              10      RET
       FA0B                     CODE_COLON_SHIFT:
00080B FA0B CDFEF8          17      CALL KEY_BREAK_WAIT
00080E FA0E 3E2A             7      LD A, '*'
000810 FA10 C9              10      RET
       FA11                     CODE_R_SQ_PAR_SHIFT:
000811 FA11 CDFEF8          17      CALL KEY_BREAK_WAIT
000814 FA14 3E7D             7      LD A, '}'
000816 FA16 C9              10      RET
       FA17                     CODE_COMMA_SHIFT:
000817 FA17 CDFEF8          17      CALL KEY_BREAK_WAIT
00081A FA1A 3E3C             7      LD A, '<'
00081C FA1C C9              10      RET
       FA1D                     CODE_PERIOD_SHIFT:
00081D FA1D CDFEF8          17      CALL KEY_BREAK_WAIT
000820 FA20 3E3E             7      LD A, '>'
000822 FA22 C9              10      RET
       FA23                     CODE_SLASH_SHIFT:
000823 FA23 CDFEF8          17      CALL KEY_BREAK_WAIT
000826 FA26 3E3F             7      LD A, '?'
000828 FA28 C9              10      RET
                                
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; Controlキーと同時に押されたキーをゲットするサブルーチン
                                ;
                                
       FA29                     CONTROL_KEY_NEXT_GET:
000829 FA29 2100FE          10      LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
00082C FA2C 01DF0F          10      LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
       FA2F                     CONTROL_SCAN_LOOP:
00082F FA2F 0C               4      INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
000830 FA30 ED78            12      IN A,(C)
000832 FA32 77               7      LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
000833 FA33 23               6      INC HL ; メモリアドレスをインクリメント。
000834 FA34 10F9            13      DJNZ CONTROL_SCAN_LOOP ; 16回繰り返す
                                
000836 FA36 2100FE          10      LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
000839 FA39 1600             7      LD D,0H ; インデックスを 1 にする。
00083B FA3B 060F             7      LD B,0FH ; B=FH=16
00083D FA3D 1E00             7      LD E,0H
                                
                                ;
                                ; Controlキーを離すか、他のキーが押されるまではループする。
                                ;
                                
       FA3F                     CONTROL_NEXT_KEY_LOOP:
00083F FA3F 3A00FE          13      LD A, (PORT_INDEX)
000842 FA42 A7               4      AND A
000843 FA43 3E1B             7      LD A,1BH
000845 FA45 C8              11      RET Z ; [EE00]=0、SHIFTキー押されてないならリターンする。
000846 FA46 23               6      INC HL
000847 FA47 14               4      INC D
000848 FA48 7E               7      LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
000849 FA49 A7               4      AND A
00084A FA4A 2007            12      JR NZ, CONTROL_KEY_LOOP ; キーが押下されている時はジャンプする。
00084C FA4C 7A               4      LD A,D
00084D FA4D FE0F             7      CP 0FH ; D=A=16バイトチェックしたか？
00084F FA4F 28D8            12      JR Z, CONTROL_KEY_NEXT_GET ; 16バイト読み込んで、SHIFTキー以外何も押されていないなら、一番最初のループに戻る
000851 FA51 18EC            12      JR CONTROL_NEXT_KEY_LOOP ; 16バイト読んでないなら、次のメモリを読む。
                                    
       FA53                     CONTROL_KEY_LOOP:
000853 FA53 FE08             7      CP 08H
000855 FA55 CA62FA          10      JP Z, CODE_08_CONTROL
000858 FA58 FE10             7      CP 10H
00085A FA5A CA79FA          10      JP Z, CODE_10_CONTROL
00085D FA5D FE20             7      CP 20H
00085F FA5F CA81FA          10      JP Z, CODE_20_CONTROL
                                
                                
       FA62                     CODE_08_CONTROL:
000862 FA62 7D               4      LD A,L
000863 FA63 E60F             7      AND 0FH
                                
000865 FA65 FE03             7      CP 03H
000867 FA67 CA96FA          10      JP Z, CODE_E_CONTROL
00086A FA6A FE04             7      CP 04H
00086C FA6C CAA8FA          10      JP Z, CODE_R_CONTROL
00086F FA6F FE07             7      CP 07H
000871 FA71 CAB4FA          10      JP Z, CODE_U_CONTROL
000874 FA74 FE0A             7      CP 0AH
000876 FA76 CAA2FA          10      JP Z, CODE_P_CONTROL
                                
       FA79                     CODE_10_CONTROL:
000879 FA79 7D               4      LD A,L
00087A FA7A E60F             7      AND 0FH
                                
00087C FA7C FE02             7      CP 02H
00087E FA7E CAAEFA          10      JP Z, CODE_S_CONTROL
                                
       FA81                     CODE_20_CONTROL:
000881 FA81 7D               4      LD A,L
000882 FA82 E60F             7      AND 0FH
                                
000884 FA84 FE01             7      CP 01H
000886 FA86 CAC0FA          10      JP Z, CODE_Z_CONTROL
000889 FA89 FE02             7      CP 02H
00088B FA8B CABAFA          10      JP Z, CODE_X_CONTROL
00088E FA8E FE03             7      CP 03H
000890 FA90 CA9CFA          10      JP Z, CODE_C_CONTROL
                                
000893 FA93 3E00             7      LD A,0H
000895 FA95 C9              10      RET
                                
                                
       FA96                     CODE_E_CONTROL:
000896 FA96 CDFEF8          17      CALL KEY_BREAK_WAIT
000899 FA99 3E05             7      LD A, 05H
00089B FA9B C9              10      RET
       FA9C                     CODE_C_CONTROL:
00089C FA9C CDFEF8          17      CALL KEY_BREAK_WAIT
00089F FA9F 3E03             7      LD A, 03H
0008A1 FAA1 C9              10      RET
       FAA2                     CODE_P_CONTROL:
0008A2 FAA2 CDFEF8          17      CALL KEY_BREAK_WAIT
0008A5 FAA5 3E10             7      LD A, 10H
0008A7 FAA7 C9              10      RET
       FAA8                     CODE_R_CONTROL:
0008A8 FAA8 CDFEF8          17      CALL KEY_BREAK_WAIT
0008AB FAAB 3E12             7      LD A, 12H
0008AD FAAD C9              10      RET
       FAAE                     CODE_S_CONTROL:
0008AE FAAE CDFEF8          17      CALL KEY_BREAK_WAIT
0008B1 FAB1 3E13             7      LD A, 13H
0008B3 FAB3 C9              10      RET
       FAB4                     CODE_U_CONTROL:
0008B4 FAB4 CDFEF8          17      CALL KEY_BREAK_WAIT
0008B7 FAB7 3E15             7      LD A, 15H
0008B9 FAB9 C9              10      RET
       FABA                     CODE_X_CONTROL:
0008BA FABA CDFEF8          17      CALL KEY_BREAK_WAIT
0008BD FABD 3E18             7      LD A, 18H
0008BF FABF C9              10      RET
       FAC0                     CODE_Z_CONTROL:
0008C0 FAC0 CDFEF8          17      CALL KEY_BREAK_WAIT
0008C3 FAC3 3E1A             7      LD A, 1AH
0008C5 FAC5 C9              10      RET
                                
                                
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; SORD M68 memory
                                ;
                                
                                ;
                                ; for CRT control
                                ;
                                
       FAC6                     CURSOR_LOCATE:
0008C6 FAC6                         DS 02H
                                
       FAC8                     TOP_VIEW:
0008C8 FAC8                         DS 02H
                                
       FACA                     NEED_DO_SCROLL_POINT:
0008CA FACA                         DS 02H
                                
       FACC                     CR_BASE_ADDRESS:
0008CC FACC                         DS 02H
                                
       FACE                     CR_BASE_ADDRESS_PRE:
0008CE FACE                         DS 02H
                                
       FAD0                     CR_NOW_CURSOL_LOCATE:
0008D0 FAD0                         DS 02H
                                
       FAD2                     CR_NEW_ORIGIN:
0008D2 FAD2                         DS 02H
                                
       FAD4                     KEY_BUFFER:
0008D4 FAD4                         DS 0FH
                                
                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;
                                ; Keyboard map
                                ;
                                
       FAE3                     KEY_MAP:
0008E3 FAE3 0031323334353637        DB 0H,'1234567890-=',5CH,08H,0H
            3839302D3D5C0800    
0008F3 FAF3 0051574552545955        DB 0H,'QWERTYUIOP@',5BH,0DH,0DH,0H
            494F50405B0D0D00    
000903 FB03 004153444647484A        DB 0H,'ASDFGHJKL',3BH,3AH,5DH,0H,0H,0H
            4B4C3B3A5D000000    
000913 FB13 005A58435642204E        DB 0H,'ZXCVB',20H,'NM',2CH,2EH,2FH,0H,0H,0H
            4D2C2E2F000000      
                                
                                ;*****************************************************
                                ;*                                                   *
                                ;*  Unitialized RAM data areas           *
                                ;*                                                   *
                                ;*****************************************************
                                ;
       FB22                     sekdsk:     DS  1   ;seek disk number
       FB23                     sektrk:     DS  2   ;seek track number
       FB25                     seksec:     DS  1   ;seek sector number
                                ;
       FB26                     hstdsk:     DS  1   ;host disk number
       FB27                     hsttrk:     DS  2   ;host track number
       FB29                     hstsec:     DS  1   ;host sector number
                                ;
       FB2A                     sekhst:     DS  1   ;seek shr secshf
       FB2B                     hstact:     DS  1   ;host active flag
       FB2C                     hstwrt:     DS  1   ;host written flag
                                ;
       FB2D                     unacnt:     DS  1   ;unalloc rec cnt
       FB2E                     unadsk:     DS  1   ;last unalloc disk
       FB2F                     unatrk:     DS  2   ;last unalloc track
       FB31                     unasec:     DS  1   ;last unalloc sector
                                ;
       FB32                     erflag:     DS  1   ;error reporting
       FB33                     rsflag:     DS  1   ;read sector flag
       FB34                     readop:     DS  1   ;1 if read operation
       FB35                     wrtype:     DS  1   ;write operation type
       FB36                     dmaadr:     DS  2   ;last dma address
       FB38                     hstbuf:     DS  hstsiz  ;host buffer
                                ;
                                ;   the remainder of the cbios is reserved uninitialized
                                ;   data area, and does not need to be a Part of the
                                ;   system  memory image (the space must be available,
                                ;   however, between"begdat" and"enddat").
                                ;
       FC38                     track:      DS  2   ;two bytes for expansion
       FC3A                     sector:     DS  2   ;two bytes for expansion
       FC3C                     dmaad:      DS  2   ;direct memory address
       FC3E                     diskno:     DS  1   ;disk number 0-15
                                ;
                                ;   scratch ram area for bdos use
       FC3F                     begdat  EQU $   ;beginning of data area
       FC3F                     dirbf:      DS  128 ;scratch directory area
       FCBF                     all00:      DS  31  ;allocation vector 0
       FCDE                     all01:      DS  31  ;allocation vector 1
       FCFD                     all02:      DS  31  ;allocation vector 2
       FD1C                     all03:      DS  31  ;allocation vector 3
       FD3B                     chk00:      DS  16  ;check vector 0
       FD4B                     chk01:      DS  16  ;check vector 1
       FD5B                     chk02:      DS  16  ;check vector 2
       FD6B                     chk03:      DS  16  ;check vector 3
                                ;
                                
                                ;
                                ; key input scan buffer
                                ; 末尾1バイトのアドレスが00であることを期待していてる。
                                ;
       FE00                         org KEYBOARD_SCAN_BUFFER
                                
       FE00                     PORT_INDEX:
       FE00                         DS 16
                                
                                ; FDC_CONTROL_REGへのコマンドを保存しておく
                                
       FE10                     fdc_control_command:
       FE10                         DS 1
                                
       FE11                     enddat  EQU $   ;end of data area
       01D2                     datsiz  EQU $-begdat    ;   ;size of data area
                                
                                    END
[EOF:bios62k10.z80:UTF_8]
